import {
  VCounter,
  VField,
  filterFieldProps,
  makeVFieldProps
} from "./chunk-O4DTQII2.js";
import {
  VInput,
  filterInputProps,
  makeVInputProps
} from "./chunk-JNT6QJ72.js";
import {
  VList,
  VListItem
} from "./chunk-EK6LXPQE.js";
import {
  VMenu
} from "./chunk-PZ5HHPHC.js";
import {
  VChip
} from "./chunk-PKQZOGMY.js";
import {
  useLocale
} from "./chunk-ORMVQWBR.js";
import {
  useForwardRef
} from "./chunk-B7EWXTU6.js";
import {
  VDefaultsProvider
} from "./chunk-CSUU65IP.js";
import {
  makeTransitionProps
} from "./chunk-2VVRXWOG.js";
import {
  useProxiedModel
} from "./chunk-XGHWVP2J.js";
import {
  intersect_default
} from "./chunk-KQGVGIOR.js";
import {
  filterInputAttrs,
  genericComponent,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-UQ3Q3FRV.js";
import {
  Fragment,
  __objRest,
  __spreadProps,
  __spreadValues,
  computed,
  createTextVNode,
  createVNode,
  mergeProps,
  nextTick,
  ref,
  resolveDirective,
  vModelDynamic,
  watch,
  withDirectives
} from "./chunk-D573C25J.js";

// node_modules/vuetify/lib/components/VTextField/VTextField.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VTextField/VTextField.css";
var activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
var VTextField = genericComponent()({
  name: "VTextField",
  directives: {
    Intersect: intersect_default
  },
  inheritAttrs: false,
  props: __spreadValues(__spreadValues({
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: Function,
    hint: String,
    persistentHint: Boolean,
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    suffix: String,
    type: {
      type: String,
      default: "text"
    }
  }, makeVInputProps()), makeVFieldProps()),
  emits: {
    "click:append": (e) => true,
    "click:append-inner": (e) => true,
    "click:clear": (e) => true,
    "click:control": (e) => true,
    "click:input": (e) => true,
    "click:prepend": (e) => true,
    "click:prepend-inner": (e) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const counterValue = computed(() => {
      var _model$value;
      return typeof props.counterValue === "function" ? props.counterValue(model.value) : ((_model$value = model.value) != null ? _model$value : "").toString().length;
    });
    const max = computed(() => {
      if (attrs.maxlength)
        return attrs.maxlength;
      if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
        return void 0;
      return props.counter;
    });
    function onIntersect(isIntersecting, entries) {
      var _entries$0$target, _entries$0$target$foc;
      if (!props.autofocus || !isIntersecting)
        return;
      (_entries$0$target = entries[0].target) == null ? void 0 : (_entries$0$target$foc = _entries$0$target.focus) == null ? void 0 : _entries$0$target$foc.call(_entries$0$target);
    }
    const vInputRef = ref();
    const vFieldRef = ref();
    const isFocused = ref(false);
    const inputRef = ref();
    const isActive = computed(() => activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value);
    const messages = computed(() => {
      return props.messages.length ? props.messages : isFocused.value || props.persistentHint ? props.hint : "";
    });
    function onFocus() {
      if (inputRef.value !== document.activeElement) {
        var _inputRef$value;
        (_inputRef$value = inputRef.value) == null ? void 0 : _inputRef$value.focus();
      }
      if (!isFocused.value)
        isFocused.value = true;
    }
    function onControlClick(e) {
      onFocus();
      emit("click:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = "";
        emit("click:clear", e);
      });
    }
    useRender(() => {
      const hasCounter = !!(slots.counter || props.counter || props.counterValue);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const [_a] = filterInputProps(props), _b = _a, {
        modelValue: _
      } = _b, inputProps = __objRest(_b, [
        "modelValue"
      ]);
      const [fieldProps] = filterFieldProps(props);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-text-field", {
          "v-text-field--persistent-placeholder": props.persistentPlaceholder,
          "v-text-field--prefixed": props.prefix,
          "v-text-field--suffixed": props.suffix,
          "v-text-field--flush-details": ["plain", "underlined"].includes(props.variant)
        }],
        "onClick:prepend": (e) => emit("click:prepend", e),
        "onClick:append": (e) => emit("click:append", e)
      }, rootAttrs, inputProps, {
        "messages": messages.value
      }), __spreadProps(__spreadValues({}, slots), {
        default: (_ref2) => {
          let {
            isDisabled,
            isDirty,
            isReadonly,
            isValid
          } = _ref2;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "onMousedown": (e) => {
              if (e.target === inputRef.value)
                return;
              e.preventDefault();
            },
            "onClick:control": onControlClick,
            "onClick:clear": onClear,
            "onClick:prependInner": (e) => emit("click:prepend-inner", e),
            "onClick:appendInner": (e) => emit("click:append-inner", e),
            "role": "textbox"
          }, fieldProps, {
            "active": isActive.value || isDirty.value,
            "dirty": isDirty.value || props.dirty,
            "focused": isFocused.value,
            "error": isValid.value === false
          }), __spreadProps(__spreadValues({}, slots), {
            default: (_ref3) => {
              var _slots$default;
              let {
                props: _a2
              } = _ref3, _b2 = _a2, {
                class: fieldClass
              } = _b2, slotProps = __objRest(_b2, [
                "class"
              ]);
              return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                "class": "v-text-field__prefix"
              }, [props.prefix]), createVNode("div", {
                "class": fieldClass,
                "onClick": (e) => emit("click:input", e)
              }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), withDirectives(createVNode("input", mergeProps({
                "ref": inputRef,
                "onUpdate:modelValue": ($event) => model.value = $event,
                "autofocus": props.autofocus,
                "readonly": isReadonly.value,
                "disabled": isDisabled.value,
                "placeholder": props.placeholder,
                "size": 1,
                "type": props.type,
                "onFocus": onFocus,
                "onBlur": () => isFocused.value = false
              }, slotProps, inputAttrs), null), [[vModelDynamic, model.value], [resolveDirective("intersect"), {
                handler: onIntersect
              }, null, {
                once: true
              }]])]), props.suffix && createVNode("span", {
                "class": "v-text-field__suffix"
              }, [props.suffix])]);
            }
          }));
        },
        details: hasCounter ? () => createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
          "active": props.persistentCounter || isFocused.value,
          "value": counterValue.value,
          "max": max.value
        }, slots.counter)]) : void 0
      }));
    });
    return useForwardRef({}, vInputRef, vFieldRef, inputRef);
  }
});

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSelect/VSelect.css";
function genItem(item) {
  var _ref;
  return {
    title: String((_ref = typeof item === "object" ? item.title : item) != null ? _ref : ""),
    value: typeof item === "object" ? item.value : item
  };
}
var makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  menuIcon: {
    type: String,
    default: "$dropdown"
  },
  modelValue: {
    type: [Number, String, Array],
    default: () => []
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean
}, "select");
var VSelect = genericComponent()({
  name: "VSelect",
  props: __spreadValues(__spreadValues({}, makeSelectProps()), makeTransitionProps({
    transition: "scale-transition"
  })),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref2) {
    let {
      slots
    } = _ref2;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const activator = ref();
    const menu = ref(false);
    const items = computed(() => props.items.map(genItem));
    const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v), (v) => props.multiple ? v : v[0]);
    const selections = computed(() => {
      const array = [];
      let index = 0;
      for (const unwrapped of model.value) {
        const item = genItem(unwrapped);
        const found = array.find((selection) => selection.value === item.value);
        if (found == null) {
          array.push(__spreadProps(__spreadValues({}, item), {
            index
          }));
          index++;
        }
      }
      return array;
    });
    const selected = computed(() => selections.value.map((selection) => selection.value));
    function onClear(e) {
      model.value = [];
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onClickControl() {
      if (props.hideNoData && !items.value.length)
        return;
      menu.value = true;
    }
    function onKeydown(e) {
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
    }
    function select(item) {
      if (props.multiple) {
        const index = selections.value.findIndex((selection) => selection.value === item.value);
        if (index === -1) {
          model.value.push(item.value);
        } else {
          model.value = selected.value.filter((selection) => selection !== item.value);
        }
      } else {
        model.value = [item.value];
        menu.value = false;
      }
    }
    watch(() => vTextFieldRef.value, (val) => {
      activator.value = val.$el.querySelector(".v-input__control");
    });
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      return createVNode(VTextField, {
        "ref": vTextFieldRef,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true
        }],
        "appendInnerIcon": props.menuIcon,
        "readonly": true,
        "onClick:clear": onClear,
        "onClick:input": onClickControl,
        "onClick:control": onClickControl,
        "onBlur": () => menu.value = false,
        "modelValue": model.value.join(", "),
        "onKeydown": onKeydown
      }, __spreadProps(__spreadValues({}, slots), {
        default: () => createVNode(Fragment, null, [activator.value && createVNode(VMenu, {
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": activator.value,
          "contentClass": "v-select__content",
          "eager": props.eager,
          "openOnClick": false,
          "transition": props.transition
        }, {
          default: () => [createVNode(VList, {
            "selected": selected.value,
            "selectStrategy": props.multiple ? "independent" : "single-independent"
          }, {
            default: () => [!items.value.length && !props.hideNoData && createVNode(VListItem, {
              "title": t(props.noDataText)
            }, null), items.value.map((item) => createVNode(VListItem, {
              "title": item.title,
              "value": item.value,
              "onMousedown": (e) => e.preventDefault(),
              "onClick": () => select(item)
            }, null))]
          })]
        }), selections.value.map((selection, index) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(selection);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            modelValue: true
          };
          return createVNode("div", {
            "class": "v-select__selection"
          }, [hasChips && createVNode(VDefaultsProvider, {
            "defaults": {
              VChip: {
                closable: props.closableChips,
                size: "small",
                text: selection.title
              }
            }
          }, {
            default: () => [slots.chip ? slots.chip({
              props: slotProps,
              selection
            }) : createVNode(VChip, slotProps, null)]
          }), !hasChips && (slots.selection ? slots.selection({
            selection
          }) : createVNode("span", {
            "class": "v-select__selection-text"
          }, [selection.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
            "class": "v-select__selection-comma"
          }, [createTextVNode(",")])]))]);
        })])
      }));
    });
    return useForwardRef({}, vTextFieldRef);
  }
});

export {
  VTextField,
  genItem,
  makeSelectProps,
  VSelect
};
//# sourceMappingURL=chunk-WZ5JQ4AW.js.map
