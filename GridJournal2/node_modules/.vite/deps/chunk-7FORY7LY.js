import {
  VList,
  VListItem
} from "./chunk-OFWCQKID.js";
import {
  VMenu
} from "./chunk-DN3LS6V2.js";
import {
  useForwardRef
} from "./chunk-B7EWXTU6.js";
import {
  VDefaultsProvider
} from "./chunk-CSUU65IP.js";
import {
  VChip
} from "./chunk-J7IHPKJ3.js";
import {
  VExpandXTransition,
  VSlideYTransition
} from "./chunk-U3HAJG7B.js";
import {
  useProxiedModel
} from "./chunk-XGHWVP2J.js";
import {
  MaybeTransition,
  makeTransitionProps
} from "./chunk-2VVRXWOG.js";
import {
  VIcon
} from "./chunk-ZWJF76M3.js";
import {
  makeRoundedProps,
  useRounded
} from "./chunk-BDK6RZGY.js";
import {
  useBackgroundColor,
  useTextColor
} from "./chunk-GAH3NRGC.js";
import {
  makeDensityProps,
  useDensity
} from "./chunk-IBN5M5C7.js";
import {
  useLocale
} from "./chunk-ORMVQWBR.js";
import {
  intersect_default
} from "./chunk-KQGVGIOR.js";
import {
  makeTagProps
} from "./chunk-B4VPDV5P.js";
import {
  useRtl
} from "./chunk-H25UDPNT.js";
import {
  makeThemeProps,
  provideTheme
} from "./chunk-Y32YR2TB.js";
import {
  SUPPORTS_INTERSECTION,
  consoleWarn,
  convertToUnit,
  defineComponent,
  filterInputAttrs,
  genericComponent,
  getCurrentInstanceName,
  getUid,
  nullifyTransforms,
  pick,
  propsFactory,
  standardEasing,
  useRender,
  wrapInArray
} from "./chunk-UQ3Q3FRV.js";
import {
  Fragment,
  Transition,
  __objRest,
  __spreadProps,
  __spreadValues,
  computed,
  createTextVNode,
  createVNode,
  inject,
  mergeProps,
  nextTick,
  onBeforeMount,
  onBeforeUnmount,
  provide,
  ref,
  resolveDirective,
  toRef,
  vModelDynamic,
  vShow,
  watch,
  withDirectives
} from "./chunk-D573C25J.js";

// node_modules/vuetify/lib/components/VMessages/VMessages.mjs
import "D:/SEM_5/WEBDEV/PR/mission/Interactive Map/Mission6_JournalGrid/GridJournal2/node_modules/vuetify/lib/components/VMessages/VMessages.css";
var VMessages = defineComponent({
  name: "VMessages",
  props: __spreadValues({
    active: Boolean,
    color: String,
    messages: {
      type: [Array, String],
      default: () => []
    }
  }, makeTransitionProps({
    transition: {
      component: VSlideYTransition,
      leaveAbsolute: true,
      group: true
    }
  })),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const messages = computed(() => wrapInArray(props.messages));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => props.color));
    return () => createVNode(MaybeTransition, {
      "transition": props.transition,
      "tag": "div",
      "class": ["v-messages", textColorClasses.value],
      "style": textColorStyles.value
    }, {
      default: () => [props.active && messages.value.map((message, i) => createVNode("div", {
        "class": "v-messages__message",
        "key": `${i}-${messages.value}`
      }, [slots.message ? slots.message({
        message
      }) : message]))]
    });
  }
});

// node_modules/vuetify/lib/components/VInput/VInput.mjs
import "D:/SEM_5/WEBDEV/PR/mission/Interactive Map/Mission6_JournalGrid/GridJournal2/node_modules/vuetify/lib/components/VInput/VInput.css";

// node_modules/vuetify/lib/composables/form.mjs
var FormKey = Symbol.for("vuetify:form");
var makeFormProps = propsFactory({
  disabled: Boolean,
  fastFail: Boolean,
  lazyValidation: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  }
});
function createForm(props) {
  const model = useProxiedModel(props, "modelValue");
  const isDisabled = computed(() => props.disabled);
  const isReadonly = computed(() => props.readonly);
  const isValidating = ref(false);
  const items = ref([]);
  const errorMessages = ref([]);
  async function validate() {
    const results = [];
    let valid = true;
    errorMessages.value = [];
    model.value = null;
    isValidating.value = true;
    for (const item of items.value) {
      const itemErrorMessages = await item.validate();
      if (itemErrorMessages.length > 0) {
        valid = false;
        results.push({
          id: item.id,
          errorMessages: itemErrorMessages
        });
      }
      if (!valid && props.fastFail)
        break;
    }
    errorMessages.value = results;
    model.value = valid;
    isValidating.value = false;
    return {
      valid,
      errorMessages: errorMessages.value
    };
  }
  function reset() {
    items.value.forEach((item) => item.reset());
    model.value = null;
  }
  function resetValidation() {
    items.value.forEach((item) => item.resetValidation());
    errorMessages.value = [];
    model.value = null;
  }
  provide(FormKey, {
    register: (id, validate2, reset2, resetValidation2) => {
      if (items.value.some((item) => item.id === id)) {
        consoleWarn(`Duplicate input name "${id}"`);
      }
      items.value.push({
        id,
        validate: validate2,
        reset: reset2,
        resetValidation: resetValidation2
      });
    },
    unregister: (id) => {
      items.value = items.value.filter((item) => {
        return item.id !== id;
      });
    },
    isDisabled,
    isReadonly,
    isValidating,
    items
  });
  return {
    errorMessages,
    isDisabled,
    isReadonly,
    isValidating,
    items,
    validate,
    reset,
    resetValidation
  };
}
function useForm() {
  return inject(FormKey, null);
}

// node_modules/vuetify/lib/composables/validation.mjs
var makeValidationProps = propsFactory({
  disabled: Boolean,
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  readonly: Boolean,
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null
});
function useValidation(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const model = useProxiedModel(props, "modelValue");
  const form = useForm();
  const internalErrorMessages = ref([]);
  const isPristine = ref(true);
  const isDirty = computed(() => wrapInArray(model.value || []).length > 0);
  const isDisabled = computed(() => !!(props.disabled || form != null && form.isDisabled.value));
  const isReadonly = computed(() => !!(props.readonly || form != null && form.isReadonly.value));
  const errorMessages = computed(() => {
    return props.errorMessages.length ? wrapInArray(props.errorMessages) : internalErrorMessages.value;
  });
  const isValid = computed(() => {
    if (props.error || errorMessages.value.length)
      return false;
    return isPristine.value ? null : true;
  });
  const isValidating = ref(false);
  const validationClasses = computed(() => {
    return {
      [`${name}--error`]: isValid.value === false,
      [`${name}--dirty`]: isDirty.value,
      [`${name}--disabled`]: isDisabled.value,
      [`${name}--readonly`]: isReadonly.value
    };
  });
  const uid = computed(() => {
    var _props$name;
    return (_props$name = props.name) != null ? _props$name : getUid();
  });
  onBeforeMount(() => {
    form == null ? void 0 : form.register(uid.value, validate, reset, resetValidation);
  });
  onBeforeUnmount(() => {
    form == null ? void 0 : form.unregister(uid.value);
  });
  function reset() {
    resetValidation();
    model.value = null;
  }
  function resetValidation() {
    isPristine.value = true;
    internalErrorMessages.value = [];
  }
  async function validate() {
    const results = [];
    isValidating.value = true;
    for (const rule of props.rules) {
      if (results.length >= (props.maxErrors || 1)) {
        break;
      }
      const handler = typeof rule === "function" ? rule : () => rule;
      const result = await handler(model.value);
      if (result === true)
        continue;
      if (typeof result !== "string") {
        console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
        continue;
      }
      results.push(result);
    }
    internalErrorMessages.value = results;
    isValidating.value = false;
    isPristine.value = false;
    return internalErrorMessages.value;
  }
  return {
    errorMessages,
    isDirty,
    isDisabled,
    isReadonly,
    isPristine,
    isValid,
    isValidating,
    reset,
    resetValidation,
    validate,
    validationClasses
  };
}

// node_modules/vuetify/lib/components/VInput/VInput.mjs
var makeVInputProps = propsFactory(__spreadValues(__spreadValues({
  id: String,
  appendIcon: String,
  prependIcon: String,
  hideDetails: [Boolean, String],
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (v) => ["horizontal", "vertical"].includes(v)
  }
}, makeDensityProps()), makeValidationProps()));
var VInput = genericComponent()({
  name: "VInput",
  props: __spreadValues({}, makeVInputProps()),
  emits: {
    "click:prepend": (e) => true,
    "click:append": (e) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const {
      densityClasses
    } = useDensity(props);
    const {
      errorMessages,
      isDirty,
      isDisabled,
      isReadonly,
      isPristine,
      isValid,
      isValidating,
      reset,
      resetValidation,
      validate,
      validationClasses
    } = useValidation(props);
    const uid = getUid();
    const id = computed(() => props.id || `input-${uid}`);
    const slotProps = computed(() => ({
      id,
      isDirty,
      isDisabled,
      isReadonly,
      isPristine,
      isValid,
      isValidating,
      reset,
      resetValidation,
      validate
    }));
    useRender(() => {
      var _props$messages, _slots$prepend, _slots$default, _slots$append, _slots$details;
      const hasPrepend = !!(slots.prepend || props.prependIcon);
      const hasAppend = !!(slots.append || props.appendIcon);
      const hasMessages = !!((_props$messages = props.messages) != null && _props$messages.length || errorMessages.value.length);
      const hasDetails = !props.hideDetails || props.hideDetails === "auto" && hasMessages;
      return createVNode("div", {
        "class": ["v-input", `v-input--${props.direction}`, densityClasses.value, validationClasses.value]
      }, [hasPrepend && createVNode("div", {
        "class": "v-input__prepend"
      }, [slots == null ? void 0 : (_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots, slotProps.value), props.prependIcon && createVNode(VIcon, {
        "onClick": (e) => emit("click:prepend", e),
        "icon": props.prependIcon
      }, null)]), slots.default && createVNode("div", {
        "class": "v-input__control"
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
        "class": "v-input__append"
      }, [slots == null ? void 0 : (_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots, slotProps.value), props.appendIcon && createVNode(VIcon, {
        "onClick": (e) => emit("click:append", e),
        "icon": props.appendIcon
      }, null)]), hasDetails && createVNode("div", {
        "class": "v-input__details"
      }, [createVNode(VMessages, {
        "active": hasMessages,
        "messages": errorMessages.value.length > 0 ? errorMessages.value : props.messages
      }, {
        message: slots.message
      }), (_slots$details = slots.details) == null ? void 0 : _slots$details.call(slots, slotProps.value)])]);
    });
    return {
      reset,
      resetValidation,
      validate
    };
  }
});
function filterInputProps(props) {
  return pick(props, Object.keys(VInput.props));
}

// node_modules/vuetify/lib/components/VLabel/VLabel.mjs
import "D:/SEM_5/WEBDEV/PR/mission/Interactive Map/Mission6_JournalGrid/GridJournal2/node_modules/vuetify/lib/components/VLabel/VLabel.css";
var VLabel = defineComponent({
  name: "VLabel",
  props: __spreadValues({
    text: String
  }, makeThemeProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      var _slots$default;
      return createVNode("label", {
        "class": "v-label"
      }, [props.text, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    };
  }
});

// node_modules/vuetify/lib/components/VField/VFieldLabel.mjs
var VFieldLabel = defineComponent({
  name: "VFieldLabel",
  props: {
    floating: Boolean
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      return createVNode(VLabel, {
        "class": ["v-field-label", {
          "v-field-label--floating": props.floating
        }],
        "aria-hidden": props.floating || void 0
      }, slots);
    };
  }
});

// node_modules/vuetify/lib/components/VProgressLinear/VProgressLinear.mjs
import "D:/SEM_5/WEBDEV/PR/mission/Interactive Map/Mission6_JournalGrid/GridJournal2/node_modules/vuetify/lib/components/VProgressLinear/VProgressLinear.css";

// node_modules/vuetify/lib/composables/intersectionObserver.mjs
function useIntersectionObserver(callback) {
  const intersectionRef = ref();
  const isIntersecting = ref(false);
  if (SUPPORTS_INTERSECTION) {
    const observer = new IntersectionObserver((entries) => {
      callback == null ? void 0 : callback(entries, observer);
      isIntersecting.value = !!entries.find((entry) => entry.isIntersecting);
    });
    onBeforeUnmount(() => {
      observer.disconnect();
    });
    watch(intersectionRef, (newValue, oldValue) => {
      if (oldValue) {
        observer.unobserve(oldValue);
        isIntersecting.value = false;
      }
      if (newValue)
        observer.observe(newValue);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef,
    isIntersecting
  };
}

// node_modules/vuetify/lib/components/VProgressLinear/VProgressLinear.mjs
var VProgressLinear = defineComponent({
  name: "VProgressLinear",
  props: __spreadValues(__spreadValues(__spreadValues({
    active: {
      type: Boolean,
      default: true
    },
    bgColor: String,
    bgOpacity: [Number, String],
    bufferValue: {
      type: [Number, String],
      default: 0
    },
    clickable: Boolean,
    color: String,
    height: {
      type: [Number, String],
      default: 4
    },
    indeterminate: Boolean,
    max: {
      type: [Number, String],
      default: 100
    },
    modelValue: {
      type: [Number, String],
      default: 0
    },
    reverse: Boolean,
    stream: Boolean,
    striped: Boolean,
    roundedBar: Boolean
  }, makeRoundedProps()), makeTagProps()), makeThemeProps()),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const progress = useProxiedModel(props, "modelValue");
    const {
      isRtl
    } = useRtl();
    const {
      themeClasses
    } = provideTheme(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(props, "color");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(computed(() => props.bgColor || props.color));
    const {
      backgroundColorClasses: barColorClasses,
      backgroundColorStyles: barColorStyles
    } = useBackgroundColor(props, "color");
    const {
      roundedClasses
    } = useRounded(props);
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const max = computed(() => parseInt(props.max, 10));
    const height = computed(() => parseInt(props.height, 10));
    const normalizedBuffer = computed(() => parseFloat(props.bufferValue) / max.value * 100);
    const normalizedValue = computed(() => parseFloat(progress.value) / max.value * 100);
    const isReversed = computed(() => isRtl.value !== props.reverse);
    const transition = computed(() => props.indeterminate ? "fade-transition" : "slide-x-transition");
    const opacity = computed(() => {
      return props.bgOpacity == null ? props.bgOpacity : parseFloat(props.bgOpacity);
    });
    function handleClick(e) {
      if (!intersectionRef.value)
        return;
      const {
        left,
        right,
        width
      } = intersectionRef.value.getBoundingClientRect();
      const value = isReversed.value ? width - e.clientX + (right - width) : e.clientX - left;
      progress.value = Math.round(value / width * max.value);
    }
    return () => createVNode(props.tag, {
      "ref": intersectionRef,
      "class": ["v-progress-linear", {
        "v-progress-linear--active": props.active && isIntersecting.value,
        "v-progress-linear--reverse": isReversed.value,
        "v-progress-linear--rounded": props.rounded,
        "v-progress-linear--rounded-bar": props.roundedBar,
        "v-progress-linear--striped": props.striped
      }, roundedClasses.value, themeClasses.value],
      "style": {
        height: props.active ? convertToUnit(height.value) : 0,
        "--v-progress-linear-height": convertToUnit(height.value)
      },
      "role": "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": props.max,
      "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value,
      "onClick": props.clickable && handleClick
    }, {
      default: () => [props.stream && createVNode("div", {
        "class": ["v-progress-linear__stream", textColorClasses.value],
        "style": __spreadProps(__spreadValues({}, textColorStyles.value), {
          [isReversed.value ? "left" : "right"]: convertToUnit(-height.value),
          borderTop: `${convertToUnit(height.value / 2)} dotted`,
          opacity: opacity.value,
          top: `calc(50% - ${convertToUnit(height.value / 4)})`,
          width: convertToUnit(100 - normalizedBuffer.value, "%"),
          "--v-progress-linear-stream-to": convertToUnit(height.value * (isReversed.value ? 1 : -1))
        })
      }, null), createVNode("div", {
        "class": ["v-progress-linear__background", backgroundColorClasses.value],
        "style": [backgroundColorStyles.value, {
          opacity: opacity.value,
          width: convertToUnit(!props.stream ? 100 : normalizedBuffer.value, "%")
        }]
      }, null), createVNode(Transition, {
        "name": transition.value
      }, {
        default: () => [!props.indeterminate ? createVNode("div", {
          "class": ["v-progress-linear__determinate", barColorClasses.value],
          "style": [barColorStyles.value, {
            width: convertToUnit(normalizedValue.value, "%")
          }]
        }, null) : createVNode("div", {
          "class": "v-progress-linear__indeterminate"
        }, [["long", "short"].map((bar) => createVNode("div", {
          "key": bar,
          "class": ["v-progress-linear__indeterminate", bar, barColorClasses.value],
          "style": barColorStyles.value
        }, null))])]
      }), slots.default && createVNode("div", {
        "class": "v-progress-linear__content"
      }, [slots.default({
        value: normalizedValue.value,
        buffer: normalizedBuffer.value
      })])]
    });
  }
});

// node_modules/vuetify/lib/components/VField/VField.mjs
import "D:/SEM_5/WEBDEV/PR/mission/Interactive Map/Mission6_JournalGrid/GridJournal2/node_modules/vuetify/lib/components/VField/VField.css";

// node_modules/vuetify/lib/composables/loader.mjs
var makeLoaderProps = propsFactory({
  loading: Boolean
}, "loader");
function useLoader(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const loaderClasses = computed(() => ({
    [`${name}--loading`]: props.loading
  }));
  return {
    loaderClasses
  };
}
function LoaderSlot(props, _ref) {
  var _slots$default;
  let {
    slots
  } = _ref;
  return createVNode("div", {
    "class": `${props.name}__loader`
  }, [((_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
    color: props.color,
    isActive: props.active
  })) || createVNode(VProgressLinear, {
    "active": props.active,
    "color": props.color,
    "height": "2",
    "indeterminate": true
  }, null)]);
}

// node_modules/vuetify/lib/composables/focus.mjs
var makeFocusProps = propsFactory({
  focused: Boolean
}, "focus");
function useFocus(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const isFocused = useProxiedModel(props, "focused");
  const focusClasses = computed(() => {
    return {
      [`${name}--focused`]: isFocused.value
    };
  });
  function focus() {
    isFocused.value = true;
  }
  function blur() {
    isFocused.value = false;
  }
  return {
    focusClasses,
    isFocused,
    focus,
    blur
  };
}

// node_modules/vuetify/lib/components/VField/VField.mjs
var allowedVariants = ["underlined", "outlined", "filled", "contained", "plain"];
var makeVFieldProps = propsFactory(__spreadValues(__spreadValues({
  appendInnerIcon: String,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: String,
    default: "$clear"
  },
  active: Boolean,
  color: String,
  dirty: Boolean,
  disabled: Boolean,
  error: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: String,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (v) => allowedVariants.includes(v)
  }
}, makeThemeProps()), makeLoaderProps()), "v-field");
var VField = genericComponent()({
  name: "VField",
  inheritAttrs: false,
  props: __spreadValues(__spreadValues({
    id: String
  }, makeFocusProps()), makeVFieldProps()),
  emits: {
    "click:clear": (e) => true,
    "click:prepend-inner": (e) => true,
    "click:append-inner": (e) => true,
    "click:control": (e) => true,
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      loaderClasses
    } = useLoader(props);
    const {
      focusClasses,
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const isActive = computed(() => props.dirty || props.active);
    const hasLabel = computed(() => !props.singleLine && !!(props.label || slots.label));
    const uid = getUid();
    const id = computed(() => props.id || `input-${uid}`);
    const labelRef = ref();
    const floatingLabelRef = ref();
    const controlRef = ref();
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => {
      return isActive.value && isFocused.value && !props.error && !props.disabled ? props.color : void 0;
    }));
    watch(isActive, (val) => {
      if (hasLabel.value) {
        const el = labelRef.value.$el;
        const targetEl = floatingLabelRef.value.$el;
        const rect = nullifyTransforms(el);
        const targetRect = targetEl.getBoundingClientRect();
        const x = targetRect.x - rect.x;
        const y = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
        const targetWidth = targetRect.width / 0.75;
        const width = Math.abs(targetWidth - rect.width) > 1 ? {
          maxWidth: convertToUnit(targetWidth)
        } : void 0;
        const duration = parseFloat(getComputedStyle(el).transitionDuration) * 1e3;
        const scale = parseFloat(getComputedStyle(targetEl).getPropertyValue("--v-field-label-scale"));
        el.style.visibility = "visible";
        targetEl.style.visibility = "hidden";
        el.animate([{
          transform: "translate(0)"
        }, __spreadValues({
          transform: `translate(${x}px, ${y}px) scale(${scale})`
        }, width)], {
          duration,
          easing: standardEasing,
          direction: val ? "normal" : "reverse"
        }).finished.then(() => {
          el.style.removeProperty("visibility");
          targetEl.style.removeProperty("visibility");
        });
      }
    }, {
      flush: "post"
    });
    const slotProps = computed(() => ({
      isActive,
      isFocused,
      controlRef,
      blur,
      focus
    }));
    function onClick(e) {
      if (e.target !== document.activeElement) {
        e.preventDefault();
      }
      emit("click:control", e);
    }
    useRender(() => {
      var _slots$prependInner, _slots$default, _slots$appendInner;
      const isOutlined = props.variant === "outlined";
      const hasPrepend = slots.prependInner || props.prependInnerIcon;
      const hasClear = !!(props.clearable || slots.clear);
      const hasAppend = !!(slots.appendInner || props.appendInnerIcon || hasClear);
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      return createVNode("div", mergeProps({
        "class": ["v-field", {
          "v-field--active": isActive.value,
          "v-field--appended": hasAppend,
          "v-field--disabled": props.disabled,
          "v-field--dirty": props.dirty,
          "v-field--error": props.error,
          "v-field--has-background": !!props.bgColor,
          "v-field--persistent-clear": props.persistentClear,
          "v-field--prepended": hasPrepend,
          "v-field--reverse": props.reverse,
          "v-field--single-line": props.singleLine,
          [`v-field--variant-${props.variant}`]: true
        }, themeClasses.value, backgroundColorClasses.value, focusClasses.value, loaderClasses.value],
        "style": [backgroundColorStyles.value, textColorStyles.value],
        "onClick": onClick
      }, attrs), [createVNode("div", {
        "class": "v-field__overlay"
      }, null), createVNode(LoaderSlot, {
        "name": "v-field",
        "active": props.loading,
        "color": props.error ? "error" : props.color
      }, {
        default: slots.loader
      }), hasPrepend && createVNode("div", {
        "class": "v-field__prepend-inner"
      }, [props.prependInnerIcon && createVNode(VIcon, {
        "onClick": (e) => emit("click:prepend-inner", e),
        "icon": props.prependInnerIcon
      }, null), slots == null ? void 0 : (_slots$prependInner = slots.prependInner) == null ? void 0 : _slots$prependInner.call(slots, slotProps.value)]), createVNode("div", {
        "class": "v-field__field"
      }, [["contained", "filled"].includes(props.variant) && hasLabel.value && createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "class": [textColorClasses.value],
        "floating": true
      }, {
        default: () => [label]
      }), createVNode(VFieldLabel, {
        "ref": labelRef,
        "for": id.value
      }, {
        default: () => [label]
      }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, __spreadProps(__spreadValues({}, slotProps.value), {
        props: {
          id: id.value,
          class: "v-field__input"
        },
        focus,
        blur
      }))]), hasClear && createVNode(VExpandXTransition, null, {
        default: () => [withDirectives(createVNode("div", {
          "class": "v-field__clearable"
        }, [slots.clear ? slots.clear() : createVNode(VIcon, {
          "onClick": (e) => emit("click:clear", e),
          "icon": props.clearIcon
        }, null)]), [[vShow, props.dirty]])]
      }), hasAppend && createVNode("div", {
        "class": "v-field__append-inner"
      }, [slots == null ? void 0 : (_slots$appendInner = slots.appendInner) == null ? void 0 : _slots$appendInner.call(slots, slotProps.value), props.appendInnerIcon && createVNode(VIcon, {
        "onClick": (e) => emit("click:append-inner", e),
        "icon": props.appendInnerIcon
      }, null)]), createVNode("div", {
        "class": ["v-field__outline", textColorClasses.value]
      }, [isOutlined && createVNode(Fragment, null, [createVNode("div", {
        "class": "v-field__outline__start"
      }, null), hasLabel.value && createVNode("div", {
        "class": "v-field__outline__notch"
      }, [createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "floating": true
      }, {
        default: () => [label]
      })]), createVNode("div", {
        "class": "v-field__outline__end"
      }, null)]), ["plain", "underlined"].includes(props.variant) && hasLabel.value && createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "floating": true
      }, {
        default: () => [label]
      })])]);
    });
    return {
      controlRef
    };
  }
});
function filterFieldProps(attrs) {
  return pick(attrs, Object.keys(VField.props));
}

// node_modules/vuetify/lib/components/VCounter/VCounter.mjs
import "D:/SEM_5/WEBDEV/PR/mission/Interactive Map/Mission6_JournalGrid/GridJournal2/node_modules/vuetify/lib/components/VCounter/VCounter.css";
var VCounter = defineComponent({
  name: "VCounter",
  functional: true,
  props: __spreadValues({
    active: Boolean,
    max: [Number, String],
    value: {
      type: [Number, String],
      default: 0
    }
  }, makeTransitionProps({
    transition: {
      component: VSlideYTransition
    }
  })),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const counter = computed(() => {
      return props.max ? `${props.value} / ${props.max}` : String(props.value);
    });
    return () => {
      return createVNode(MaybeTransition, {
        "transition": props.transition
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": "v-counter"
        }, [slots.default ? slots.default({
          counter: counter.value,
          max: props.max,
          value: props.value
        }) : counter.value]), [[vShow, props.active]])]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VTextField/VTextField.mjs
import "D:/SEM_5/WEBDEV/PR/mission/Interactive Map/Mission6_JournalGrid/GridJournal2/node_modules/vuetify/lib/components/VTextField/VTextField.css";
var activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
var VTextField = genericComponent()({
  name: "VTextField",
  directives: {
    Intersect: intersect_default
  },
  inheritAttrs: false,
  props: __spreadValues(__spreadValues({
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: Function,
    hint: String,
    persistentHint: Boolean,
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    suffix: String,
    type: {
      type: String,
      default: "text"
    }
  }, makeVInputProps()), makeVFieldProps()),
  emits: {
    "click:append": (e) => true,
    "click:append-inner": (e) => true,
    "click:clear": (e) => true,
    "click:control": (e) => true,
    "click:input": (e) => true,
    "click:prepend": (e) => true,
    "click:prepend-inner": (e) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const counterValue = computed(() => {
      var _model$value;
      return typeof props.counterValue === "function" ? props.counterValue(model.value) : ((_model$value = model.value) != null ? _model$value : "").toString().length;
    });
    const max = computed(() => {
      if (attrs.maxlength)
        return attrs.maxlength;
      if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
        return void 0;
      return props.counter;
    });
    function onIntersect(isIntersecting, entries) {
      var _entries$0$target, _entries$0$target$foc;
      if (!props.autofocus || !isIntersecting)
        return;
      (_entries$0$target = entries[0].target) == null ? void 0 : (_entries$0$target$foc = _entries$0$target.focus) == null ? void 0 : _entries$0$target$foc.call(_entries$0$target);
    }
    const vInputRef = ref();
    const vFieldRef = ref();
    const isFocused = ref(false);
    const inputRef = ref();
    const isActive = computed(() => activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value);
    const messages = computed(() => {
      return props.messages.length ? props.messages : isFocused.value || props.persistentHint ? props.hint : "";
    });
    function onFocus() {
      if (inputRef.value !== document.activeElement) {
        var _inputRef$value;
        (_inputRef$value = inputRef.value) == null ? void 0 : _inputRef$value.focus();
      }
      if (!isFocused.value)
        isFocused.value = true;
    }
    function onControlClick(e) {
      onFocus();
      emit("click:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = "";
        emit("click:clear", e);
      });
    }
    useRender(() => {
      const hasCounter = !!(slots.counter || props.counter || props.counterValue);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const [_a] = filterInputProps(props), _b = _a, {
        modelValue: _
      } = _b, inputProps = __objRest(_b, [
        "modelValue"
      ]);
      const [fieldProps] = filterFieldProps(props);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-text-field", {
          "v-text-field--persistent-placeholder": props.persistentPlaceholder,
          "v-text-field--prefixed": props.prefix,
          "v-text-field--suffixed": props.suffix,
          "v-text-field--flush-details": ["plain", "underlined"].includes(props.variant)
        }],
        "onClick:prepend": (e) => emit("click:prepend", e),
        "onClick:append": (e) => emit("click:append", e)
      }, rootAttrs, inputProps, {
        "messages": messages.value
      }), __spreadProps(__spreadValues({}, slots), {
        default: (_ref2) => {
          let {
            isDisabled,
            isDirty,
            isReadonly,
            isValid
          } = _ref2;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "onMousedown": (e) => {
              if (e.target === inputRef.value)
                return;
              e.preventDefault();
            },
            "onClick:control": onControlClick,
            "onClick:clear": onClear,
            "onClick:prependInner": (e) => emit("click:prepend-inner", e),
            "onClick:appendInner": (e) => emit("click:append-inner", e),
            "role": "textbox"
          }, fieldProps, {
            "active": isActive.value || isDirty.value,
            "dirty": isDirty.value || props.dirty,
            "focused": isFocused.value,
            "error": isValid.value === false
          }), __spreadProps(__spreadValues({}, slots), {
            default: (_ref3) => {
              var _slots$default;
              let {
                props: _a2
              } = _ref3, _b2 = _a2, {
                class: fieldClass
              } = _b2, slotProps = __objRest(_b2, [
                "class"
              ]);
              return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                "class": "v-text-field__prefix"
              }, [props.prefix]), createVNode("div", {
                "class": fieldClass,
                "onClick": (e) => emit("click:input", e)
              }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), withDirectives(createVNode("input", mergeProps({
                "ref": inputRef,
                "onUpdate:modelValue": ($event) => model.value = $event,
                "autofocus": props.autofocus,
                "readonly": isReadonly.value,
                "disabled": isDisabled.value,
                "placeholder": props.placeholder,
                "size": 1,
                "type": props.type,
                "onFocus": onFocus,
                "onBlur": () => isFocused.value = false
              }, slotProps, inputAttrs), null), [[vModelDynamic, model.value], [resolveDirective("intersect"), {
                handler: onIntersect
              }, null, {
                once: true
              }]])]), props.suffix && createVNode("span", {
                "class": "v-text-field__suffix"
              }, [props.suffix])]);
            }
          }));
        },
        details: hasCounter ? () => createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
          "active": props.persistentCounter || isFocused.value,
          "value": counterValue.value,
          "max": max.value
        }, slots.counter)]) : void 0
      }));
    });
    return useForwardRef({}, vInputRef, vFieldRef, inputRef);
  }
});

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
import "D:/SEM_5/WEBDEV/PR/mission/Interactive Map/Mission6_JournalGrid/GridJournal2/node_modules/vuetify/lib/components/VSelect/VSelect.css";
function genItem(item) {
  var _ref;
  return {
    title: String((_ref = typeof item === "object" ? item.title : item) != null ? _ref : ""),
    value: typeof item === "object" ? item.value : item
  };
}
var makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  menuIcon: {
    type: String,
    default: "$dropdown"
  },
  modelValue: {
    type: [Number, String, Array],
    default: () => []
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean
}, "select");
var VSelect = genericComponent()({
  name: "VSelect",
  props: __spreadValues(__spreadValues({}, makeSelectProps()), makeTransitionProps({
    transition: "scale-transition"
  })),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref2) {
    let {
      slots
    } = _ref2;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const activator = ref();
    const menu = ref(false);
    const items = computed(() => props.items.map(genItem));
    const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v), (v) => props.multiple ? v : v[0]);
    const selections = computed(() => {
      const array = [];
      let index = 0;
      for (const unwrapped of model.value) {
        const item = genItem(unwrapped);
        const found = array.find((selection) => selection.value === item.value);
        if (found == null) {
          array.push(__spreadProps(__spreadValues({}, item), {
            index
          }));
          index++;
        }
      }
      return array;
    });
    const selected = computed(() => selections.value.map((selection) => selection.value));
    function onClear(e) {
      model.value = [];
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onClickControl() {
      if (props.hideNoData && !items.value.length)
        return;
      menu.value = true;
    }
    function onKeydown(e) {
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
    }
    function select(item) {
      if (props.multiple) {
        const index = selections.value.findIndex((selection) => selection.value === item.value);
        if (index === -1) {
          model.value.push(item.value);
        } else {
          model.value = selected.value.filter((selection) => selection !== item.value);
        }
      } else {
        model.value = [item.value];
        menu.value = false;
      }
    }
    watch(() => vTextFieldRef.value, (val) => {
      activator.value = val.$el.querySelector(".v-input__control");
    });
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      return createVNode(VTextField, {
        "ref": vTextFieldRef,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true
        }],
        "appendInnerIcon": props.menuIcon,
        "readonly": true,
        "onClick:clear": onClear,
        "onClick:input": onClickControl,
        "onClick:control": onClickControl,
        "onBlur": () => menu.value = false,
        "modelValue": model.value.join(", "),
        "onKeydown": onKeydown
      }, __spreadProps(__spreadValues({}, slots), {
        default: () => createVNode(Fragment, null, [activator.value && createVNode(VMenu, {
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": activator.value,
          "contentClass": "v-select__content",
          "eager": props.eager,
          "openOnClick": false,
          "transition": props.transition
        }, {
          default: () => [createVNode(VList, {
            "selected": selected.value,
            "selectStrategy": props.multiple ? "independent" : "single-independent"
          }, {
            default: () => [!items.value.length && !props.hideNoData && createVNode(VListItem, {
              "title": t(props.noDataText)
            }, null), items.value.map((item) => createVNode(VListItem, {
              "title": item.title,
              "value": item.value,
              "onMousedown": (e) => e.preventDefault(),
              "onClick": () => select(item)
            }, null))]
          })]
        }), selections.value.map((selection, index) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(selection);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            modelValue: true
          };
          return createVNode("div", {
            "class": "v-select__selection"
          }, [hasChips && createVNode(VDefaultsProvider, {
            "defaults": {
              VChip: {
                closable: props.closableChips,
                size: "small",
                text: selection.title
              }
            }
          }, {
            default: () => [slots.chip ? slots.chip({
              props: slotProps,
              selection
            }) : createVNode(VChip, slotProps, null)]
          }), !hasChips && (slots.selection ? slots.selection({
            selection
          }) : createVNode("span", {
            "class": "v-select__selection-text"
          }, [selection.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
            "class": "v-select__selection-comma"
          }, [createTextVNode(",")])]))]);
        })])
      }));
    });
    return useForwardRef({}, vTextFieldRef);
  }
});

export {
  VMessages,
  makeFormProps,
  createForm,
  makeValidationProps,
  useValidation,
  makeVInputProps,
  VInput,
  filterInputProps,
  VLabel,
  VFieldLabel,
  useIntersectionObserver,
  VProgressLinear,
  makeLoaderProps,
  useLoader,
  LoaderSlot,
  makeFocusProps,
  useFocus,
  makeVFieldProps,
  VField,
  filterFieldProps,
  VCounter,
  VTextField,
  genItem,
  makeSelectProps,
  VSelect
};
//# sourceMappingURL=chunk-7FORY7LY.js.map
