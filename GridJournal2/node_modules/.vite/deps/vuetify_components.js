import {
  VCard,
  VCardActions,
  VCardAvatar,
  VCardHeader,
  VCardHeaderText,
  VCardImg,
  VCardSubtitle,
  VCardText,
  VCardTitle
} from "./chunk-HYJYL2OL.js";
import {
  VSheet
} from "./chunk-BYKKHUEJ.js";
import {
  LoaderSlot,
  VCounter,
  VField,
  VFieldLabel,
  VInput,
  VLabel,
  VMessages,
  VProgressLinear,
  VTextarea,
  createForm,
  filterFieldProps,
  filterInputProps,
  makeFocusProps,
  makeFormProps,
  makeLoaderProps,
  makeVFieldProps,
  makeVInputProps,
  makeValidationProps,
  useFocus,
  useIntersectionObserver,
  useLoader,
  useValidation
} from "./chunk-IUJQGYMI.js";
import {
  VCol,
  VContainer,
  VRow,
  VSpacer
} from "./chunk-DDO3D2X4.js";
import {
  VMain
} from "./chunk-6PPURUU3.js";
import {
  VNavigationDrawer
} from "./chunk-HFI3X576.js";
import {
  VList,
  VListGroup,
  VListImg,
  VListItem,
  VListItemAvatar,
  VListItemHeader,
  VListItemMedia,
  VListItemSubtitle,
  VListItemTitle,
  VListSubheader
} from "./chunk-4QANKG34.js";
import {
  VDivider
} from "./chunk-LVLFFY7P.js";
import {
  VAvatar
} from "./chunk-UREWVWRL.js";
import {
  VMenu,
  VOverlay,
  makeDelayProps,
  makeLazyProps,
  useDelay,
  useLazy
} from "./chunk-XRBVAQNG.js";
import {
  VCarouselReverseTransition,
  VCarouselTransition,
  VDialogBottomTransition,
  VDialogTopTransition,
  VDialogTransition,
  VExpandTransition,
  VExpandXTransition,
  VFabTransition,
  VFadeTransition,
  VMenuTransition,
  VScaleTransition,
  VScrollXReverseTransition,
  VScrollXTransition,
  VScrollYReverseTransition,
  VScrollYTransition,
  VSlideXReverseTransition,
  VSlideXTransition,
  VSlideYReverseTransition,
  VSlideYTransition,
  VTabReverseTransition,
  VTabTransition
} from "./chunk-U3HAJG7B.js";
import {
  provideLocale,
  useLocale
} from "./chunk-OTEJ75TU.js";
import {
  useDisplay
} from "./chunk-KRPMDXOE.js";
import {
  Touch,
  touch_default
} from "./chunk-X3GFINAV.js";
import "./chunk-2GVUDMII.js";
import {
  VApp
} from "./chunk-GWDL4RM4.js";
import {
  provideRtl,
  useRtl
} from "./chunk-H25UDPNT.js";
import {
  VAppBar,
  VAppBarNavIcon,
  VAppBarTitle
} from "./chunk-RUHPUJ2O.js";
import {
  VToolbar,
  VToolbarItems,
  VToolbarTitle
} from "./chunk-FTL7AZEJ.js";
import {
  VDefaultsProvider
} from "./chunk-CSUU65IP.js";
import {
  useForwardRef
} from "./chunk-B7EWXTU6.js";
import {
  VImg
} from "./chunk-JR4PDOKM.js";
import {
  VResponsive
} from "./chunk-63KHAUAZ.js";
import {
  VBtn,
  VBtnGroup,
  VBtnToggle,
  VBtnToggleSymbol,
  makeGroupItemProps,
  makeGroupProps,
  useGroup,
  useGroupItem
} from "./chunk-FPX7BUN5.js";
import {
  makePositionProps,
  usePosition
} from "./chunk-CSBFHE7X.js";
import {
  genOverlays,
  makeVariantProps,
  useVariant
} from "./chunk-IQQB7JHA.js";
import {
  makeBorderProps,
  makeElevationProps,
  useBorder,
  useElevation
} from "./chunk-XOXYXY6M.js";
import {
  makeDensityProps,
  useDensity
} from "./chunk-IBN5M5C7.js";
import {
  makeRoundedProps,
  useRounded
} from "./chunk-BDK6RZGY.js";
import {
  VIcon,
  makeSizeProps,
  useSize
} from "./chunk-EV466AUN.js";
import {
  makeTagProps
} from "./chunk-B4VPDV5P.js";
import {
  MaybeTransition,
  makeTransitionProps
} from "./chunk-2VVRXWOG.js";
import {
  makeRouterProps,
  useLink
} from "./chunk-QUPZSGAQ.js";
import {
  useProxiedModel
} from "./chunk-XGHWVP2J.js";
import {
  makeDimensionProps,
  useDimension
} from "./chunk-QOITRFI2.js";
import {
  useBackgroundColor,
  useTextColor
} from "./chunk-GAH3NRGC.js";
import {
  VClassIcon,
  VComponentIcon,
  VLigatureIcon,
  VSvgIcon
} from "./chunk-I6AOM24X.js";
import {
  intersect_default
} from "./chunk-KQGVGIOR.js";
import {
  Ripple,
  ripple_default
} from "./chunk-HSLPPIOR.js";
import {
  createLayout,
  makeLayoutItemProps,
  makeLayoutProps,
  useLayoutItem,
  useResizeObserver
} from "./chunk-I3XX2AN2.js";
import {
  makeThemeProps,
  provideTheme,
  useTheme
} from "./chunk-Y32YR2TB.js";
import {
  HSLAtoHSVA,
  HSVAtoCSS,
  HSVAtoHSLA,
  HSVAtoHex,
  HSVAtoRGBA,
  HexToHSVA,
  IN_BROWSER,
  RGBAtoHSVA,
  SUPPORTS_FOCUS_VISIBLE,
  clamp,
  convertToUnit,
  createRange,
  createSimpleFunctional,
  deepEqual,
  defineComponent as defineComponent2,
  filterInputAttrs,
  genericComponent,
  getContrast,
  getCurrentInstance,
  getEventCoordinates,
  getPropertyFromItem,
  getScrollParent,
  getUid,
  humanReadableFileSize,
  keyValues,
  parseHex,
  pick,
  propsFactory,
  provideDefaults,
  standardEasing,
  useRender,
  wrapInArray
} from "./chunk-UQ3Q3FRV.js";
import "./chunk-NFMXVBYB.js";
import {
  Fragment,
  __objRest,
  __spreadProps,
  __spreadValues,
  computed,
  createTextVNode,
  createVNode,
  defineComponent,
  inject,
  mergeProps,
  nextTick,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  provide,
  ref,
  resolveDirective,
  toRef,
  unref,
  vModelDynamic,
  vShow,
  watch,
  watchEffect,
  withDirectives
} from "./chunk-D573C25J.js";

// node_modules/vuetify/lib/components/VAlert/VAlert.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VAlert/VAlert.css";

// node_modules/vuetify/lib/components/VAlert/VAlertTitle.mjs
var VAlertTitle = createSimpleFunctional("v-alert-title");

// node_modules/vuetify/lib/components/VAlert/VAlert.mjs
var allowedTypes = ["success", "info", "warning", "error"];
var VAlert = defineComponent2({
  name: "VAlert",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    border: {
      type: [Boolean, String],
      validator: (val) => {
        return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
      }
    },
    borderColor: String,
    closable: Boolean,
    closeIcon: {
      type: String,
      default: "$close"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    icon: {
      type: [Boolean, String],
      default: null
    },
    modelValue: {
      type: Boolean,
      default: true
    },
    prominent: Boolean,
    title: String,
    text: String,
    type: {
      type: String,
      validator: (val) => allowedTypes.includes(val)
    }
  }, makeDensityProps()), makeDimensionProps()), makeElevationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "contained-flat"
  })),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const icon = computed(() => {
      var _props$icon;
      if (props.icon === false)
        return void 0;
      if (!props.type)
        return props.icon;
      return (_props$icon = props.icon) != null ? _props$icon : `$${props.type}`;
    });
    const variantProps = computed(() => {
      var _props$color;
      return {
        color: (_props$color = props.color) != null ? _props$color : props.type,
        textColor: props.textColor,
        variant: props.variant
      };
    });
    const {
      themeClasses
    } = provideTheme(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "borderColor"));
    function onCloseClick(e) {
      isActive.value = false;
    }
    return () => {
      var _slots$default;
      const hasClose = !!(slots.close || props.closable);
      const hasPrepend = !!(slots.prepend || icon.value);
      const hasTitle = !!(slots.title || props.title);
      return isActive.value && createVNode(props.tag, {
        "class": ["v-alert", props.border && {
          "v-alert--border": !!props.border,
          [`v-alert--border-${props.border === true ? "start" : props.border}`]: true
        }, {
          "v-alert--prominent": props.prominent
        }, themeClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value],
        "style": [colorStyles.value, dimensionStyles.value, positionStyles.value],
        "role": "alert"
      }, {
        default: () => [genOverlays(false, "v-alert"), props.border && createVNode("div", {
          "class": ["v-alert__border", textColorClasses.value],
          "style": textColorStyles.value
        }, null), hasPrepend && createVNode("div", {
          "class": "v-alert__prepend"
        }, [slots.prepend ? slots.prepend() : createVNode(VIcon, {
          "icon": icon.value,
          "size": props.prominent ? "large" : "default"
        }, null)]), createVNode("div", {
          "class": "v-alert__content"
        }, [hasTitle && createVNode(VAlertTitle, null, {
          default: () => [slots.title ? slots.title() : props.title]
        }), slots.text ? slots.text() : props.text, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]), slots.append && createVNode("div", {
          "class": "v-alert__append"
        }, [slots.append()]), hasClose && createVNode("div", {
          "class": "v-alert__close",
          "onClick": onCloseClick
        }, [slots.close ? slots.close() : createVNode(VIcon, {
          "icon": props.closeIcon,
          "size": "small"
        }, null)])]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.css";

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSelect/VSelect.css";

// node_modules/vuetify/lib/components/VChip/VChip.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VChip/VChip.css";

// node_modules/vuetify/lib/components/VChipGroup/VChipGroup.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VChipGroup/VChipGroup.css";
var VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
var VChipGroup = defineComponent2({
  name: "VChipGroup",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues({
    column: Boolean,
    filter: Boolean,
    valueComparator: {
      type: Function,
      default: deepEqual
    }
  }, makeGroupProps({
    selectedClass: "v-chip--selected"
  })), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "contained-text"
  })),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      isSelected,
      select,
      next,
      prev,
      selected
    } = useGroup(props, VChipGroupSymbol);
    provideDefaults({
      VChip: {
        color: toRef(props, "color"),
        filter: toRef(props, "filter"),
        variant: toRef(props, "variant")
      }
    });
    return () => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-chip-group", {
          "v-chip-group--column": props.column
        }, themeClasses.value]
      }, {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          isSelected,
          select,
          next,
          prev,
          selected: selected.value
        })]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VChip/VChip.mjs
var VChip = defineComponent2({
  name: "VChip",
  directives: {
    Ripple
  },
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    activeClass: String,
    appendAvatar: String,
    appendIcon: String,
    closable: Boolean,
    closeIcon: {
      type: String,
      default: "$delete"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: String,
      default: "$complete"
    },
    label: Boolean,
    link: Boolean,
    pill: Boolean,
    prependAvatar: String,
    prependIcon: String,
    ripple: {
      type: Boolean,
      default: true
    },
    text: String,
    modelValue: {
      type: Boolean,
      default: true
    }
  }, makeBorderProps()), makeDensityProps()), makeElevationProps()), makeGroupItemProps()), makeRoundedProps()), makeRouterProps()), makeSizeProps()), makeTagProps({
    tag: "span"
  })), makeThemeProps()), makeVariantProps({
    variant: "contained-text"
  })),
  emits: {
    "click:close": (e) => true,
    "update:active": (value) => true,
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      elevationClasses
    } = useElevation(props);
    const group = useGroupItem(props, VChipGroupSymbol, false);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      sizeClasses
    } = useSize(props);
    const {
      densityClasses
    } = useDensity(props);
    const link = useLink(props, attrs);
    function onCloseClick(e) {
      isActive.value = false;
      emit("click:close", e);
    }
    return () => {
      var _slots$default, _slots$default2;
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasAppend = !!(slots.append || props.appendIcon || props.appendAvatar);
      const hasClose = !!(slots.close || props.closable);
      const hasFilter = !!(slots.filter || props.filter) && group;
      const hasPrepend = !!(slots.prepend || props.prependIcon || props.prependAvatar);
      const hasColor = !group || group.isSelected.value;
      const isClickable = !props.disabled && (!!group || link.isClickable.value || props.link);
      const onClickFunc = props.link ? props.link : group == null ? void 0 : group.toggle;
      return isActive.value && withDirectives(createVNode(Tag, {
        "class": ["v-chip", {
          "v-chip--disabled": props.disabled,
          "v-chip--label": props.label,
          "v-chip--link": isClickable,
          "v-chip--pill": props.pill
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group == null ? void 0 : group.selectedClass.value],
        "style": [hasColor ? colorStyles.value : void 0],
        "disabled": props.disabled || void 0,
        "draggable": props.draggable,
        "href": link.href.value,
        "onClick": isClickable && onClickFunc
      }, {
        default: () => [genOverlays(isClickable, "v-chip"), hasFilter && createVNode(VExpandXTransition, null, {
          default: () => [withDirectives(createVNode("div", {
            "class": "v-chip__filter"
          }, [slots.filter ? slots.filter() : createVNode(VIcon, {
            "icon": props.filterIcon
          }, null)]), [[vShow, group.isSelected.value]])]
        }), hasPrepend && createVNode("div", {
          "class": "v-chip__prepend"
        }, [slots.prepend ? slots.prepend() : createVNode(VAvatar, {
          "icon": props.prependIcon,
          "image": props.prependAvatar,
          "size": props.size
        }, null)]), (_slots$default = (_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots, {
          isSelected: group == null ? void 0 : group.isSelected.value,
          selectedClass: group == null ? void 0 : group.selectedClass.value,
          select: group == null ? void 0 : group.select,
          toggle: group == null ? void 0 : group.toggle,
          value: group == null ? void 0 : group.value.value,
          disabled: props.disabled
        })) != null ? _slots$default : props.text, hasAppend && createVNode("div", {
          "class": "v-chip__append"
        }, [slots.append ? slots.append() : createVNode(VAvatar, {
          "icon": props.appendIcon,
          "image": props.appendAvatar,
          "size": props.size
        }, null)]), hasClose && createVNode("div", {
          "class": "v-chip__close",
          "onClick": onCloseClick
        }, [slots.close ? slots.close({
          props: {
            onClick: onCloseClick
          }
        }) : createVNode(VIcon, {
          "icon": props.closeIcon,
          "size": "x-small"
        }, null)])]
      }), [[resolveDirective("ripple"), isClickable && props.ripple, null]]);
    };
  }
});

// node_modules/vuetify/lib/components/VTextField/VTextField.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VTextField/VTextField.css";
var activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
var VTextField = genericComponent()({
  name: "VTextField",
  directives: {
    Intersect: intersect_default
  },
  inheritAttrs: false,
  props: __spreadValues(__spreadValues({
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: Function,
    hint: String,
    persistentHint: Boolean,
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    suffix: String,
    type: {
      type: String,
      default: "text"
    }
  }, makeVInputProps()), makeVFieldProps()),
  emits: {
    "click:append": (e) => true,
    "click:append-inner": (e) => true,
    "click:clear": (e) => true,
    "click:control": (e) => true,
    "click:input": (e) => true,
    "click:prepend": (e) => true,
    "click:prepend-inner": (e) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const counterValue = computed(() => {
      var _model$value;
      return typeof props.counterValue === "function" ? props.counterValue(model.value) : ((_model$value = model.value) != null ? _model$value : "").toString().length;
    });
    const max = computed(() => {
      if (attrs.maxlength)
        return attrs.maxlength;
      if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
        return void 0;
      return props.counter;
    });
    function onIntersect(isIntersecting, entries) {
      var _entries$0$target, _entries$0$target$foc;
      if (!props.autofocus || !isIntersecting)
        return;
      (_entries$0$target = entries[0].target) == null ? void 0 : (_entries$0$target$foc = _entries$0$target.focus) == null ? void 0 : _entries$0$target$foc.call(_entries$0$target);
    }
    const vInputRef = ref();
    const vFieldRef = ref();
    const isFocused = ref(false);
    const inputRef = ref();
    const isActive = computed(() => activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value);
    const messages = computed(() => {
      return props.messages.length ? props.messages : isFocused.value || props.persistentHint ? props.hint : "";
    });
    function onFocus() {
      if (inputRef.value !== document.activeElement) {
        var _inputRef$value;
        (_inputRef$value = inputRef.value) == null ? void 0 : _inputRef$value.focus();
      }
      if (!isFocused.value)
        isFocused.value = true;
    }
    function onControlClick(e) {
      onFocus();
      emit("click:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = "";
        emit("click:clear", e);
      });
    }
    useRender(() => {
      const hasCounter = !!(slots.counter || props.counter || props.counterValue);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const [_a] = filterInputProps(props), _b = _a, {
        modelValue: _
      } = _b, inputProps = __objRest(_b, [
        "modelValue"
      ]);
      const [fieldProps] = filterFieldProps(props);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-text-field", {
          "v-text-field--persistent-placeholder": props.persistentPlaceholder,
          "v-text-field--prefixed": props.prefix,
          "v-text-field--suffixed": props.suffix,
          "v-text-field--flush-details": ["plain", "underlined"].includes(props.variant)
        }],
        "onClick:prepend": (e) => emit("click:prepend", e),
        "onClick:append": (e) => emit("click:append", e)
      }, rootAttrs, inputProps, {
        "messages": messages.value
      }), __spreadProps(__spreadValues({}, slots), {
        default: (_ref2) => {
          let {
            isDisabled,
            isDirty,
            isReadonly,
            isValid
          } = _ref2;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "onMousedown": (e) => {
              if (e.target === inputRef.value)
                return;
              e.preventDefault();
            },
            "onClick:control": onControlClick,
            "onClick:clear": onClear,
            "onClick:prependInner": (e) => emit("click:prepend-inner", e),
            "onClick:appendInner": (e) => emit("click:append-inner", e),
            "role": "textbox"
          }, fieldProps, {
            "active": isActive.value || isDirty.value,
            "dirty": isDirty.value || props.dirty,
            "focused": isFocused.value,
            "error": isValid.value === false
          }), __spreadProps(__spreadValues({}, slots), {
            default: (_ref3) => {
              var _slots$default;
              let {
                props: _a2
              } = _ref3, _b2 = _a2, {
                class: fieldClass
              } = _b2, slotProps = __objRest(_b2, [
                "class"
              ]);
              return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                "class": "v-text-field__prefix"
              }, [props.prefix]), createVNode("div", {
                "class": fieldClass,
                "onClick": (e) => emit("click:input", e)
              }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), withDirectives(createVNode("input", mergeProps({
                "ref": inputRef,
                "onUpdate:modelValue": ($event) => model.value = $event,
                "autofocus": props.autofocus,
                "readonly": isReadonly.value,
                "disabled": isDisabled.value,
                "placeholder": props.placeholder,
                "size": 1,
                "type": props.type,
                "onFocus": onFocus,
                "onBlur": () => isFocused.value = false
              }, slotProps, inputAttrs), null), [[vModelDynamic, model.value], [resolveDirective("intersect"), {
                handler: onIntersect
              }, null, {
                once: true
              }]])]), props.suffix && createVNode("span", {
                "class": "v-text-field__suffix"
              }, [props.suffix])]);
            }
          }));
        },
        details: hasCounter ? () => createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
          "active": props.persistentCounter || isFocused.value,
          "value": counterValue.value,
          "max": max.value
        }, slots.counter)]) : void 0
      }));
    });
    return useForwardRef({}, vInputRef, vFieldRef, inputRef);
  }
});

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
function genItem(item) {
  var _ref;
  return {
    title: String((_ref = typeof item === "object" ? item.title : item) != null ? _ref : ""),
    value: typeof item === "object" ? item.value : item
  };
}
var makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  menuIcon: {
    type: String,
    default: "$dropdown"
  },
  modelValue: {
    type: [Number, String, Array],
    default: () => []
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean
}, "select");
var VSelect = genericComponent()({
  name: "VSelect",
  props: __spreadValues(__spreadValues({}, makeSelectProps()), makeTransitionProps({
    transition: "scale-transition"
  })),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref2) {
    let {
      slots
    } = _ref2;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const activator = ref();
    const menu = ref(false);
    const items = computed(() => props.items.map(genItem));
    const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v), (v) => props.multiple ? v : v[0]);
    const selections = computed(() => {
      const array = [];
      let index = 0;
      for (const unwrapped of model.value) {
        const item = genItem(unwrapped);
        const found = array.find((selection) => selection.value === item.value);
        if (found == null) {
          array.push(__spreadProps(__spreadValues({}, item), {
            index
          }));
          index++;
        }
      }
      return array;
    });
    const selected = computed(() => selections.value.map((selection) => selection.value));
    function onClear(e) {
      model.value = [];
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onClickControl() {
      if (props.hideNoData && !items.value.length)
        return;
      menu.value = true;
    }
    function onKeydown(e) {
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
    }
    function select(item) {
      if (props.multiple) {
        const index = selections.value.findIndex((selection) => selection.value === item.value);
        if (index === -1) {
          model.value.push(item.value);
        } else {
          model.value = selected.value.filter((selection) => selection !== item.value);
        }
      } else {
        model.value = [item.value];
        menu.value = false;
      }
    }
    watch(() => vTextFieldRef.value, (val) => {
      activator.value = val.$el.querySelector(".v-input__control");
    });
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      return createVNode(VTextField, {
        "ref": vTextFieldRef,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true
        }],
        "appendInnerIcon": props.menuIcon,
        "readonly": true,
        "onClick:clear": onClear,
        "onClick:input": onClickControl,
        "onClick:control": onClickControl,
        "onBlur": () => menu.value = false,
        "modelValue": model.value.join(", "),
        "onKeydown": onKeydown
      }, __spreadProps(__spreadValues({}, slots), {
        default: () => createVNode(Fragment, null, [activator.value && createVNode(VMenu, {
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": activator.value,
          "contentClass": "v-select__content",
          "eager": props.eager,
          "openOnClick": false,
          "transition": props.transition
        }, {
          default: () => [createVNode(VList, {
            "selected": selected.value,
            "selectStrategy": props.multiple ? "independent" : "single-independent"
          }, {
            default: () => [!items.value.length && !props.hideNoData && createVNode(VListItem, {
              "title": t(props.noDataText)
            }, null), items.value.map((item) => createVNode(VListItem, {
              "title": item.title,
              "value": item.value,
              "onMousedown": (e) => e.preventDefault(),
              "onClick": () => select(item)
            }, null))]
          })]
        }), selections.value.map((selection, index) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(selection);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            modelValue: true
          };
          return createVNode("div", {
            "class": "v-select__selection"
          }, [hasChips && createVNode(VDefaultsProvider, {
            "defaults": {
              VChip: {
                closable: props.closableChips,
                size: "small",
                text: selection.title
              }
            }
          }, {
            default: () => [slots.chip ? slots.chip({
              props: slotProps,
              selection
            }) : createVNode(VChip, slotProps, null)]
          }), !hasChips && (slots.selection ? slots.selection({
            selection
          }) : createVNode("span", {
            "class": "v-select__selection-text"
          }, [selection.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
            "class": "v-select__selection-comma"
          }, [createTextVNode(",")])]))]);
        })])
      }));
    });
    return useForwardRef({}, vTextFieldRef);
  }
});

// node_modules/vuetify/lib/composables/filter.mjs
var defaultFilter = (value, query, item) => {
  if (value == null || query == null)
    return -1;
  return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());
};
var makeFilterProps = propsFactory({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function filterItems(items, query, options) {
  var _options$default, _options$customKeyFil;
  const array = [];
  const filter = (_options$default = options == null ? void 0 : options.default) != null ? _options$default : defaultFilter;
  const keys = options != null && options.filterKeys ? wrapInArray(options.filterKeys) : false;
  const customFiltersLength = Object.keys((_options$customKeyFil = options == null ? void 0 : options.customKeyFilter) != null ? _options$customKeyFil : {}).length;
  if (!(items != null && items.length))
    return array;
  loop:
    for (const item of items) {
      const customMatches = {};
      const defaultMatches = {};
      let match = -1;
      if (query && typeof item === "object" && !(options != null && options.noFilter)) {
        const filterKeys = keys || Object.keys(item);
        for (const key of filterKeys) {
          var _options$customKeyFil2;
          const value = getPropertyFromItem(item, key, item);
          const keyFilter = options == null ? void 0 : (_options$customKeyFil2 = options.customKeyFilter) == null ? void 0 : _options$customKeyFil2[key];
          match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);
          if (match !== -1 && match !== false) {
            if (keyFilter)
              customMatches[key] = match;
            else
              defaultMatches[key] = match;
          } else if ((options == null ? void 0 : options.filterMode) === "every") {
            continue loop;
          }
        }
        const defaultMatchesLength = Object.keys(defaultMatches).length;
        const customMatchesLength = Object.keys(customMatches).length;
        if (!defaultMatchesLength && !customMatchesLength)
          continue;
        if ((options == null ? void 0 : options.filterMode) === "union" && customMatchesLength !== customFiltersLength && !defaultMatchesLength)
          continue;
        if ((options == null ? void 0 : options.filterMode) === "intersection" && (customMatchesLength !== customFiltersLength || !defaultMatchesLength))
          continue;
      }
      array.push({
        item,
        matches: __spreadValues(__spreadValues({}, defaultMatches), customMatches)
      });
    }
  return array;
}
function useFilter(props, items, query) {
  const strQuery = computed(() => typeof (query == null ? void 0 : query.value) !== "string" && typeof (query == null ? void 0 : query.value) !== "number" ? "" : String(query.value));
  const filteredItems = computed(() => {
    return filterItems(unref(items), strQuery.value, {
      customKeyFilter: props.customKeyFilter,
      default: props.customFilter,
      filterKeys: props.filterKeys,
      filterMode: props.filterMode,
      noFilter: props.noFilter
    });
  });
  return {
    filteredItems
  };
}

// node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.mjs
function highlightResult(text, matches, length) {
  if (Array.isArray(matches))
    throw new Error("Multiple matches is not implemented");
  return typeof matches === "number" && ~matches ? createVNode(Fragment, null, [createVNode("span", {
    "class": "v-autocomplete__unmask"
  }, [text.substr(0, matches)]), createVNode("span", {
    "class": "v-autocomplete__mask"
  }, [text.substr(matches, length)]), createVNode("span", {
    "class": "v-autocomplete__unmask"
  }, [text.substr(matches + length)])]) : text;
}
var VAutocomplete = genericComponent()({
  name: "VAutocomplete",
  props: __spreadValues(__spreadValues(__spreadValues({
    search: String
  }, makeFilterProps({
    filterKeys: ["title"]
  })), makeSelectProps()), makeTransitionProps({
    transition: false
  })),
  emits: {
    "click:clear": (e) => true,
    "update:search": (val) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const activator = ref();
    const isFocused = ref(false);
    const isPristine = ref(true);
    const menu = ref(false);
    const items = computed(() => props.items.map(genItem));
    const search = useProxiedModel(props, "search", "");
    const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v || []), (v) => props.multiple ? v : v[0]);
    const {
      filteredItems
    } = useFilter(props, items, computed(() => isPristine.value ? void 0 : search.value));
    const selections = computed(() => {
      const array = [];
      let index = 0;
      for (const unwrapped of model.value) {
        const item = genItem(unwrapped);
        const found = array.find((selection) => selection.value === item.value);
        if (found == null) {
          array.push(__spreadProps(__spreadValues({}, item), {
            index
          }));
          index++;
        }
      }
      return array;
    });
    const selected = computed(() => selections.value.map((selection) => selection.value));
    function onClear(e) {
      model.value = [];
      if (props.openOnClear) {
        menu.value = true;
      }
      search.value = "";
    }
    function onClickControl() {
      if (props.hideNoData && !filteredItems.value.length)
        return;
      menu.value = true;
    }
    function onKeydown(e) {
      if (["Enter", "ArrowDown"].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape"].includes(e.key)) {
        menu.value = false;
      }
      if (["Enter", "Escape", "Tab"].includes(e.key)) {
        isPristine.value = true;
      }
    }
    function onAfterLeave() {
      if (isFocused.value)
        isPristine.value = true;
    }
    const isSelecting = ref(false);
    function select(item) {
      if (props.multiple) {
        const index = selections.value.findIndex((selection) => selection.value === item.value);
        if (index === -1) {
          model.value.push(item.value);
        } else {
          model.value = selected.value.filter((selection) => selection !== item.value);
        }
      } else {
        model.value = [item.value];
        isSelecting.value = true;
        search.value = item.title;
        menu.value = false;
        isPristine.value = true;
        nextTick(() => isSelecting.value = false);
      }
    }
    watch(() => vTextFieldRef.value, (val) => {
      activator.value = val.$el.querySelector(".v-input__control");
    });
    watch(isFocused, (val) => {
      if (val) {
        var _model$value;
        isSelecting.value = true;
        search.value = props.multiple ? "" : String((_model$value = model.value) != null ? _model$value : "");
        isPristine.value = true;
        nextTick(() => isSelecting.value = false);
      } else {
        menu.value = false;
        search.value = "";
      }
    });
    watch(search, (val) => {
      if (!isFocused.value || isSelecting.value)
        return;
      if (val)
        menu.value = true;
      isPristine.value = !val;
    });
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      return createVNode(VTextField, {
        "ref": vTextFieldRef,
        "modelValue": search.value,
        "onUpdate:modelValue": ($event) => search.value = $event,
        "class": ["v-autocomplete", {
          "v-autocomplete--active-menu": menu.value,
          "v-autocomplete--chips": !!props.chips,
          [`v-autocomplete--${props.multiple ? "multiple" : "single"}`]: true
        }],
        "appendInnerIcon": props.menuIcon,
        "dirty": selected.value.length > 0,
        "onClick:clear": onClear,
        "onClick:control": onClickControl,
        "onClick:input": onClickControl,
        "onFocus": () => isFocused.value = true,
        "onBlur": () => isFocused.value = false,
        "onKeydown": onKeydown
      }, __spreadProps(__spreadValues({}, slots), {
        default: () => createVNode(Fragment, null, [activator.value && createVNode(VMenu, {
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": activator.value,
          "contentClass": "v-autocomplete__content",
          "eager": props.eager,
          "openOnClick": false,
          "transition": props.transition,
          "onAfterLeave": onAfterLeave
        }, {
          default: () => [createVNode(VList, {
            "selected": selected.value,
            "selectStrategy": props.multiple ? "independent" : "single-independent"
          }, {
            default: () => [!filteredItems.value.length && !props.hideNoData && createVNode(VListItem, {
              "title": t(props.noDataText)
            }, null), filteredItems.value.map((_ref2) => {
              let {
                item,
                matches
              } = _ref2;
              return createVNode(VListItem, {
                "value": item.value,
                "onMousedown": (e) => e.preventDefault(),
                "onClick": () => select(item)
              }, {
                title: () => {
                  var _search$value$length, _search$value;
                  return isPristine.value ? item.title : highlightResult(item.title, matches.title, (_search$value$length = (_search$value = search.value) == null ? void 0 : _search$value.length) != null ? _search$value$length : 0);
                }
              });
            })]
          })]
        }), selections.value.map((selection, index) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(selection);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            modelValue: true
          };
          return createVNode("div", {
            "class": "v-autocomplete__selection"
          }, [hasChips && createVNode(VDefaultsProvider, {
            "defaults": {
              VChip: {
                closable: props.closableChips,
                size: "small",
                text: selection.title
              }
            }
          }, {
            default: () => [slots.chip ? slots.chip({
              props: slotProps,
              selection
            }) : createVNode(VChip, slotProps, null)]
          }), !hasChips && (slots.selection ? slots.selection({
            selection
          }) : createVNode("span", {
            "class": "v-autocomplete__selection-text"
          }, [selection.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
            "class": "v-autocomplete__selection-comma"
          }, [createTextVNode(",")])]))]);
        })])
      }));
    });
    return useForwardRef({
      filteredItems
    }, vTextFieldRef);
  }
});

// node_modules/vuetify/lib/components/VBadge/VBadge.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VBadge/VBadge.css";
var VBadge = defineComponent2({
  name: "VBadge",
  inheritAttrs: false,
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues({
    bordered: Boolean,
    color: String,
    content: [Number, String],
    dot: Boolean,
    floating: Boolean,
    icon: String,
    inline: Boolean,
    label: {
      type: String,
      default: "$vuetify.badge"
    },
    location: {
      type: String,
      default: "top-end",
      validator: (value) => {
        const [vertical, horizontal] = (value != null ? value : "").split("-");
        return ["top", "bottom"].includes(vertical) && ["start", "end"].includes(horizontal);
      }
    },
    max: [Number, String],
    modelValue: {
      type: Boolean,
      default: true
    },
    offsetX: [Number, String],
    offsetY: [Number, String],
    textColor: String
  }, makeRoundedProps()), makeTagProps()), makeThemeProps()), makeTransitionProps({
    transition: "scale-rotate-transition"
  })),
  setup(props, ctx) {
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      isRtl
    } = useRtl();
    const {
      roundedClasses
    } = useRounded(props);
    const {
      t
    } = useLocale();
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "textColor"));
    const {
      themeClasses
    } = useTheme();
    const position = computed(() => {
      return props.floating ? props.dot ? 2 : 4 : props.dot ? 8 : 12;
    });
    function calculatePosition(offset) {
      return `calc(100% - ${convertToUnit(position.value + parseInt(offset != null ? offset : 0, 10))})`;
    }
    const locationStyles = computed(() => {
      var _props$location;
      const [vertical, horizontal] = ((_props$location = props.location) != null ? _props$location : "").split("-");
      const styles = {
        bottom: "auto",
        left: "auto",
        right: "auto",
        top: "auto"
      };
      if (!props.inline) {
        const isRight = isRtl.value && horizontal === "end" || !isRtl.value && horizontal === "start";
        styles[isRight ? "right" : "left"] = calculatePosition(props.offsetX);
        styles[vertical === "top" ? "bottom" : "top"] = calculatePosition(props.offsetY);
      }
      return styles;
    });
    return () => {
      var _ctx$slots$default, _ctx$slots, _ctx$slots$badge, _ctx$slots2;
      const value = Number(props.content);
      const content = !props.max || isNaN(value) ? props.content : value <= props.max ? value : `${props.max}+`;
      const [badgeAttrs, attrs] = pick(ctx.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return createVNode(props.tag, mergeProps({
        "class": ["v-badge", {
          "v-badge--bordered": props.bordered,
          "v-badge--dot": props.dot,
          "v-badge--floating": props.floating,
          "v-badge--inline": props.inline
        }]
      }, attrs), {
        default: () => [createVNode("div", {
          "class": "v-badge__wrapper"
        }, [(_ctx$slots$default = (_ctx$slots = ctx.slots).default) == null ? void 0 : _ctx$slots$default.call(_ctx$slots), createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [withDirectives(createVNode("span", mergeProps({
            "class": ["v-badge__badge", backgroundColorClasses.value, roundedClasses.value, textColorClasses.value, themeClasses.value],
            "style": [backgroundColorStyles.value, locationStyles.value, textColorStyles.value],
            "aria-atomic": "true",
            "aria-label": t(props.label, value),
            "aria-live": "polite",
            "role": "status"
          }, badgeAttrs), [props.dot ? void 0 : ctx.slots.badge ? (_ctx$slots$badge = (_ctx$slots2 = ctx.slots).badge) == null ? void 0 : _ctx$slots$badge.call(_ctx$slots2) : props.icon ? createVNode(VIcon, {
            "icon": props.icon
          }, null) : createVNode("span", {
            "class": "v-badge__content"
          }, [content])]), [[vShow, props.modelValue]])]
        })])]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VBanner/VBanner.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VBanner/VBanner.css";

// node_modules/vuetify/lib/components/VBanner/VBannerActions.mjs
var VBannerActions = createSimpleFunctional("v-banner-actions");

// node_modules/vuetify/lib/components/VBanner/VBannerText.mjs
var VBannerText = createSimpleFunctional("v-banner-text");

// node_modules/vuetify/lib/components/VBanner/VBanner.mjs
var VBanner = defineComponent2({
  name: "VBanner",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    avatar: String,
    color: String,
    icon: String,
    lines: String,
    sticky: Boolean,
    text: String
  }, makeBorderProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      mobile
    } = useDisplay();
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    useRender(() => {
      var _slots$default;
      const hasAvatar = !!(props.avatar || props.icon || slots.avatar || slots.icon);
      const hasText = !!(props.text || slots.text);
      const hasContent = hasAvatar || hasText || slots.default;
      return createVNode(props.tag, {
        "class": ["v-banner", {
          "v-banner--mobile": mobile.value,
          "v-banner--sticky": props.sticky,
          [`v-banner--${props.lines}-line`]: true
        }, borderClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, themeClasses.value],
        "style": [dimensionStyles.value, positionStyles.value],
        "role": "banner"
      }, {
        default: () => [hasContent && createVNode("div", {
          "class": "v-banner__content"
        }, [hasAvatar && createVNode(VDefaultsProvider, {
          "defaults": {
            VAvatar: {
              color: props.color,
              density: props.density,
              icon: props.icon,
              image: props.avatar
            }
          }
        }, {
          default: () => [createVNode("div", {
            "class": "v-banner__avatar"
          }, [slots.avatar ? slots.avatar() : createVNode(VAvatar, null, null)])]
        }), hasText && createVNode(VBannerText, null, {
          default: () => [slots.text ? slots.text() : props.text]
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              color: props.color,
              density: props.density,
              variant: "text"
            }
          }
        }, {
          default: () => [createVNode(VBannerActions, null, {
            default: slots.actions
          })]
        })]
      });
    });
  }
});

// node_modules/vuetify/lib/components/VBottomNavigation/VBottomNavigation.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VBottomNavigation/VBottomNavigation.css";
var VBottomNavigation = defineComponent2({
  name: "VBottomNavigation",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    bgColor: String,
    color: String,
    grow: Boolean,
    mode: {
      type: String,
      validator: (v) => !v || ["horizontal", "shift"].includes(v)
    },
    height: {
      type: [Number, String],
      default: 56
    }
  }, makeBorderProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeLayoutItemProps({
    name: "bottom-navigation"
  })), makeTagProps({
    tag: "header"
  })), makeGroupProps({
    modelValue: true,
    selectedClass: "v-btn--selected"
  })), makeThemeProps()),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = useTheme();
    const {
      borderClasses
    } = useBorder(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    const {
      densityClasses
    } = useDensity(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const height = computed(() => Number(props.height) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0));
    const isActive = useProxiedModel(props, "modelValue", props.modelValue);
    const {
      layoutItemStyles
    } = useLayoutItem({
      id: props.name,
      priority: computed(() => parseInt(props.priority, 10)),
      position: computed(() => "bottom"),
      layoutSize: computed(() => isActive.value ? height.value : 0),
      elementSize: height,
      active: isActive,
      absolute: toRef(props, "absolute")
    });
    useGroup(props, VBtnToggleSymbol);
    provideDefaults({
      VBtn: {
        color: toRef(props, "color"),
        density: toRef(props, "density"),
        stacked: computed(() => props.mode !== "horizontal"),
        variant: "text"
      }
    }, {
      scoped: true
    });
    return () => {
      return createVNode(props.tag, {
        "class": ["v-bottom-navigation", {
          "v-bottom-navigation--active": isActive.value,
          "v-bottom-navigation--grow": props.grow,
          "v-bottom-navigation--shift": props.mode === "shift"
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value],
        "style": [backgroundColorStyles.value, layoutItemStyles.value, {
          height: convertToUnit(height.value),
          transform: `translateY(${convertToUnit(!isActive.value ? 100 : 0, "%")})`
        }]
      }, {
        default: () => [slots.default && createVNode("div", {
          "class": "v-bottom-navigation__content"
        }, [slots.default()])]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbs.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbs.css";

// node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbsItem.mjs
var VBreadcrumbsItem = defineComponent2({
  name: "VBreadcrumbsItem",
  props: __spreadValues(__spreadValues({
    active: Boolean,
    activeClass: String,
    activeColor: String,
    color: String,
    disabled: Boolean,
    text: String
  }, makeRouterProps()), makeTagProps({
    tag: "li"
  })),
  setup(props, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      isExactActive,
      isLink,
      navigate
    } = useLink(props, attrs);
    const isActive = computed(() => props.active || (isExactActive == null ? void 0 : isExactActive.value));
    const color = computed(() => isActive.value ? props.activeColor : props.color);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(color);
    useRender(() => {
      const Tag = isLink.value ? "a" : props.tag;
      const hasText = !!(slots.default || props.text);
      return createVNode(Tag, {
        "class": ["v-breadcrumbs-item", {
          "v-breadcrumbs-item--active": isActive.value,
          "v-breadcrumbs-item--disabled": props.disabled,
          "v-breadcrumbs-item--link": isLink.value,
          [`${props.activeClass}`]: isActive.value && props.activeClass
        }, textColorClasses.value],
        "style": [textColorStyles.value],
        "aria-current": isActive.value ? "page" : void 0,
        "onClick": isActive.value && navigate
      }, {
        default: hasText ? () => {
          var _slots$default, _slots$default2;
          return (_slots$default = (_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots)) != null ? _slots$default : props.text;
        } : void 0
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbsDivider.mjs
var VBreadcrumbsDivider = createSimpleFunctional("v-breadcrumbs-divider", "li");

// node_modules/vuetify/lib/components/VBreadcrumbs/VBreadcrumbs.mjs
var VBreadcrumbs = defineComponent2({
  name: "VBreadcrumbs",
  props: __spreadValues(__spreadValues(__spreadValues({
    activeClass: String,
    bgColor: String,
    color: String,
    disabled: Boolean,
    divider: {
      type: String,
      default: "/"
    },
    icon: String,
    items: {
      type: Array,
      default: () => []
    }
  }, makeDensityProps()), makeRoundedProps()), makeTagProps({
    tag: "ul"
  })),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      densityClasses
    } = useDensity(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    provideDefaults({
      VBreadcrumbsItem: {
        activeClass: toRef(props, "activeClass"),
        color: toRef(props, "color"),
        disabled: toRef(props, "disabled")
      }
    });
    useRender(() => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-breadcrumbs", backgroundColorClasses.value, densityClasses.value, roundedClasses.value],
        "style": backgroundColorStyles.value
      }, {
        default: () => [props.icon && createVNode(VIcon, {
          "icon": props.icon,
          "left": true
        }, null), props.items.map((item, index, array) => {
          var _slots$divider, _slots$divider2;
          return createVNode(Fragment, null, [createVNode(VBreadcrumbsItem, mergeProps({
            "key": index,
            "disabled": index >= array.length - 1
          }, typeof item === "string" ? {
            text: item
          } : item), {
            default: slots.text ? () => {
              var _slots$text;
              return (_slots$text = slots.text) == null ? void 0 : _slots$text.call(slots, {
                item,
                index
              });
            } : void 0
          }), index < array.length - 1 && createVNode(VBreadcrumbsDivider, null, {
            default: () => [(_slots$divider = (_slots$divider2 = slots.divider) == null ? void 0 : _slots$divider2.call(slots, {
              item,
              index
            })) != null ? _slots$divider : props.divider]
          })]);
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VCarousel/VCarousel.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VCarousel/VCarousel.css";

// node_modules/vuetify/lib/components/VWindow/VWindow.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VWindow/VWindow.css";
var VWindowSymbol = Symbol.for("vuetify:v-window");
var VWindowGroupSymbol = Symbol.for("vuetify:v-window-group");
var VWindow = genericComponent()({
  name: "VWindow",
  directives: {
    Touch
  },
  props: __spreadValues(__spreadValues({
    continuous: Boolean,
    nextIcon: {
      type: [Boolean, String],
      default: "$next"
    },
    prevIcon: {
      type: [Boolean, String],
      default: "$prev"
    },
    reverse: Boolean,
    showArrows: {
      type: [Boolean, String],
      validator: (v) => typeof v === "boolean" || v === "hover"
    },
    touch: {
      type: [Object, Boolean],
      default: void 0
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    modelValue: null,
    disabled: Boolean,
    selectedClass: {
      type: String,
      default: "v-window-item--active"
    },
    mandatory: {
      default: "force"
    }
  }, makeTagProps()), makeThemeProps()),
  emits: {
    "update:modelValue": (v) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      isRtl
    } = useRtl();
    const {
      t
    } = useLocale();
    const group = useGroup(props, VWindowGroupSymbol);
    const rootRef = ref();
    const isRtlReverse = computed(() => isRtl.value ? !props.reverse : props.reverse);
    const isReversed = ref(false);
    const transition = computed(() => {
      const axis = props.direction === "vertical" ? "y" : "x";
      const reverse = isRtlReverse.value ? !isReversed.value : isReversed.value;
      const direction = reverse ? "-reverse" : "";
      return `v-window-${axis}${direction}-transition`;
    });
    const transitionCount = ref(0);
    const transitionHeight = ref(void 0);
    const activeIndex = computed(() => {
      return group.items.value.findIndex((item) => group.selected.value.includes(item.id));
    });
    watch(activeIndex, (newVal, oldVal) => {
      const itemsLength = group.items.value.length;
      const lastIndex = itemsLength - 1;
      if (itemsLength <= 2) {
        isReversed.value = newVal < oldVal;
      } else if (newVal === lastIndex && oldVal === 0) {
        isReversed.value = true;
      } else if (newVal === 0 && oldVal === lastIndex) {
        isReversed.value = false;
      } else {
        isReversed.value = newVal < oldVal;
      }
    });
    provide(VWindowSymbol, {
      transition,
      isReversed,
      transitionCount,
      transitionHeight,
      rootRef
    });
    const canMoveBack = computed(() => props.continuous || activeIndex.value !== 0);
    const canMoveForward = computed(() => props.continuous || activeIndex.value !== group.items.value.length - 1);
    function prev() {
      canMoveBack.value && group.prev();
    }
    function next() {
      canMoveForward.value && group.next();
    }
    provideDefaults({
      VBtn: {
        variant: "text"
      }
    }, {
      scoped: true
    });
    const arrows = computed(() => {
      const arrows2 = [];
      const prevProps = {
        icon: isRtl.value ? props.nextIcon : props.prevIcon,
        class: `v-window__${isRtlReverse.value ? "right" : "left"}`,
        onClick: group.prev,
        ariaLabel: t("$vuetify.carousel.prev")
      };
      arrows2.push(canMoveBack.value ? slots.prev ? slots.prev({
        props: prevProps
      }) : createVNode(VBtn, prevProps, null) : createVNode("div", null, null));
      const nextProps = {
        icon: isRtl.value ? props.prevIcon : props.nextIcon,
        class: `v-window__${isRtlReverse.value ? "left" : "right"}`,
        onClick: group.next,
        ariaLabel: t("$vuetify.carousel.next")
      };
      arrows2.push(canMoveForward.value ? slots.next ? slots.next({
        props: nextProps
      }) : createVNode(VBtn, nextProps, null) : createVNode("div", null, null));
      return arrows2;
    });
    const touchOptions = computed(() => {
      if (props.touch === false)
        return props.touch;
      const options = {
        left: () => {
          isRtlReverse.value ? prev() : next();
        },
        right: () => {
          isRtlReverse.value ? next() : prev();
        },
        end: (_ref2) => {
          let {
            originalEvent
          } = _ref2;
          originalEvent.stopPropagation();
        },
        start: (_ref3) => {
          let {
            originalEvent
          } = _ref3;
          originalEvent.stopPropagation();
        }
      };
      return __spreadValues(__spreadValues({}, options), props.touch === true ? {} : props.touch);
    });
    useRender(() => {
      var _slots$default, _slots$additional;
      return withDirectives(createVNode(props.tag, {
        "ref": rootRef,
        "class": ["v-window", {
          "v-window--show-arrows-on-hover": props.showArrows === "hover"
        }, themeClasses.value]
      }, {
        default: () => [createVNode("div", {
          "class": "v-window__container",
          "style": {
            height: transitionHeight.value
          }
        }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          group
        }), props.showArrows !== false && createVNode("div", {
          "class": "v-window__controls"
        }, [arrows.value])]), (_slots$additional = slots.additional) == null ? void 0 : _slots$additional.call(slots, {
          group
        })]
      }), [[resolveDirective("touch"), touchOptions.value]]);
    });
    return {
      group
    };
  }
});

// node_modules/vuetify/lib/components/VWindow/VWindowItem.mjs
var VWindowItem = defineComponent2({
  name: "VWindowItem",
  directives: {
    Touch: touch_default
  },
  props: __spreadValues(__spreadValues({
    reverseTransition: {
      type: [Boolean, String],
      default: void 0
    },
    transition: {
      type: [Boolean, String],
      default: void 0
    }
  }, makeLazyProps()), makeGroupItemProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const window2 = inject(VWindowSymbol);
    const groupItem = useGroupItem(props, VWindowGroupSymbol);
    if (!window2 || !groupItem)
      throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const isTransitioning = ref(false);
    const hasTransition = computed(() => window2.isReversed.value ? props.reverseTransition !== false : props.transition !== false);
    function onAfterTransition() {
      if (!isTransitioning.value || !window2) {
        return;
      }
      isTransitioning.value = false;
      if (window2.transitionCount.value > 0) {
        window2.transitionCount.value -= 1;
        if (window2.transitionCount.value === 0) {
          window2.transitionHeight.value = void 0;
        }
      }
    }
    function onBeforeTransition() {
      if (isTransitioning.value || !window2) {
        return;
      }
      isTransitioning.value = true;
      if (window2.transitionCount.value === 0) {
        var _window$rootRef$value;
        window2.transitionHeight.value = convertToUnit((_window$rootRef$value = window2.rootRef.value) == null ? void 0 : _window$rootRef$value.clientHeight);
      }
      window2.transitionCount.value += 1;
    }
    function onTransitionCancelled() {
      onAfterTransition();
    }
    function onEnterTransition(el) {
      if (!isTransitioning.value) {
        return;
      }
      nextTick(() => {
        if (!hasTransition.value || !isTransitioning.value || !window2) {
          return;
        }
        window2.transitionHeight.value = convertToUnit(el.clientHeight);
      });
    }
    const transition = computed(() => {
      const name = window2.isReversed.value ? props.reverseTransition : props.transition;
      return !hasTransition.value ? false : {
        name: typeof name !== "string" ? window2.transition.value : name,
        onBeforeEnter: onBeforeTransition,
        onAfterEnter: onAfterTransition,
        onEnterCancelled: onTransitionCancelled,
        onBeforeLeave: onBeforeTransition,
        onAfterLeave: onAfterTransition,
        onLeaveCancelled: onTransitionCancelled,
        onEnter: onEnterTransition
      };
    });
    const {
      hasContent
    } = useLazy(props, groupItem.isSelected);
    return () => {
      return createVNode(MaybeTransition, {
        "transition": transition.value
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": ["v-window-item", groupItem.selectedClass.value]
        }, [slots.default && hasContent.value && slots.default()]), [[vShow, groupItem.isSelected.value]])]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VCarousel/VCarousel.mjs
var VCarousel = defineComponent2({
  name: "VCarousel",
  props: {
    color: String,
    cycle: Boolean,
    delimiterIcon: {
      type: String,
      default: "$delimiter"
    },
    height: {
      type: [Number, String],
      default: 500
    },
    hideDelimiters: Boolean,
    hideDelimiterBackground: Boolean,
    interval: {
      type: [Number, String],
      default: 6e3,
      validator: (value) => value > 0
    },
    modelValue: null,
    progress: [Boolean, String],
    showArrows: {
      type: [Boolean, String],
      default: true,
      validator: (v) => typeof v === "boolean" || v === "hover"
    },
    verticalDelimiters: [Boolean, String]
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const {
      t
    } = useLocale();
    const windowRef = ref();
    let slideTimeout = -1;
    watch(model, restartTimeout);
    watch(() => props.interval, restartTimeout);
    watch(() => props.cycle, (val) => {
      if (val)
        restartTimeout();
      else
        window.clearTimeout(slideTimeout);
    });
    onMounted(startTimeout);
    function startTimeout() {
      if (!props.cycle || !windowRef.value)
        return;
      slideTimeout = window.setTimeout(windowRef.value.group.next, +props.interval > 0 ? +props.interval : 6e3);
    }
    function restartTimeout() {
      window.clearTimeout(slideTimeout);
      window.requestAnimationFrame(startTimeout);
    }
    useRender(() => createVNode(VWindow, {
      "ref": windowRef,
      "modelValue": model.value,
      "onUpdate:modelValue": ($event) => model.value = $event,
      "class": ["v-carousel", {
        "v-carousel--hide-delimiter-background": props.hideDelimiterBackground,
        "v-carousel--vertical-delimiters": props.verticalDelimiters
      }],
      "style": {
        height: convertToUnit(props.height)
      },
      "continuous": true,
      "showArrows": props.showArrows,
      "mandatory": "force"
    }, {
      default: slots.default,
      additional: (_ref2) => {
        let {
          group
        } = _ref2;
        return createVNode(Fragment, null, [!props.hideDelimiters && createVNode("div", {
          "class": "v-carousel__controls",
          "style": {
            left: props.verticalDelimiters === "left" && props.verticalDelimiters ? 0 : "auto",
            right: props.verticalDelimiters === "right" ? 0 : "auto"
          }
        }, [group.items.value.length > 0 && createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              color: props.color,
              icon: props.delimiterIcon,
              size: "x-small",
              variant: "text"
            }
          },
          "scoped": true
        }, {
          default: () => [group.items.value.map((item) => {
            const props2 = {
              "aria-label": t("$vuetify.carousel.ariaLabel.delimiter"),
              class: [group.isSelected(item.id) && "v-btn--selected"],
              onClick: () => group.select(item.id, true)
            };
            return slots.item ? slots.item({
              props: props2,
              item
            }) : createVNode(VBtn, mergeProps(item, props2), null);
          })]
        })]), props.progress && createVNode(VProgressLinear, {
          "class": "v-carousel__progress",
          "color": typeof props.progress === "string" ? props.progress : void 0,
          "modelValue": (+model.value + 1) / group.items.value.length * 100
        }, null)]);
      },
      prev: slots.prev,
      next: slots.next
    }));
  }
});

// node_modules/vuetify/lib/components/VCarousel/VCarouselItem.mjs
var VCarouselItem = defineComponent2({
  name: "VCarouselItem",
  inheritAttrs: false,
  props: {
    value: null
  },
  setup(props, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    useRender(() => createVNode(VWindowItem, {
      "class": "v-carousel-item",
      "value": props.value
    }, {
      default: () => [createVNode(VImg, attrs, slots)]
    }));
  }
});

// node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VCheckbox/VCheckbox.css";

// node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.css";

// node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.css";
var VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
var VSelectionControlGroup = defineComponent({
  name: "VSelectionControlGroup",
  props: {
    disabled: Boolean,
    id: String,
    inline: Boolean,
    name: String,
    falseIcon: String,
    trueIcon: String,
    multiple: {
      type: Boolean,
      default: null
    },
    readonly: Boolean,
    type: String,
    modelValue: null
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const modelValue = useProxiedModel(props, "modelValue");
    const uid = getUid();
    const id = computed(() => props.id || `v-selection-control-group-${uid}`);
    const name = computed(() => props.name || id.value);
    provide(VSelectionControlGroupSymbol, {
      disabled: toRef(props, "disabled"),
      inline: toRef(props, "inline"),
      modelValue,
      multiple: computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
      name,
      falseIcon: toRef(props, "falseIcon"),
      trueIcon: toRef(props, "trueIcon"),
      readonly: toRef(props, "readonly"),
      type: toRef(props, "type")
    });
    useRender(() => {
      var _slots$default;
      return createVNode("div", {
        "class": "v-selection-control-group",
        "aria-labelled-by": props.type === "radio" ? id.value : void 0,
        "role": props.type === "radio" ? "radiogroup" : void 0
      }, [slots == null ? void 0 : (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.mjs
var makeSelectionControlProps = propsFactory(__spreadValues(__spreadValues({
  color: String,
  disabled: Boolean,
  error: Boolean,
  id: String,
  inline: Boolean,
  label: String,
  falseIcon: String,
  trueIcon: String,
  ripple: {
    type: Boolean,
    default: true
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: Boolean,
  trueValue: null,
  falseValue: null,
  modelValue: null,
  type: String,
  value: null,
  valueComparator: {
    type: Function,
    default: deepEqual
  }
}, makeThemeProps()), makeDensityProps()));
function useSelectionControl(props) {
  const group = inject(VSelectionControlGroupSymbol, void 0);
  const {
    densityClasses
  } = useDensity(props);
  const modelValue = useProxiedModel(props, "modelValue");
  const trueValue = computed(() => props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true);
  const falseValue = computed(() => props.falseValue !== void 0 ? props.falseValue : false);
  const isMultiple = computed(() => (group == null ? void 0 : group.multiple.value) || !!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
  const model = computed({
    get() {
      const val = group ? group.modelValue.value : modelValue.value;
      return isMultiple.value ? val.some((v) => props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
    },
    set(val) {
      const currentValue = val ? trueValue.value : falseValue.value;
      let newVal = currentValue;
      if (isMultiple.value) {
        newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props.valueComparator(item, trueValue.value));
      }
      if (group) {
        group.modelValue.value = newVal;
      } else {
        modelValue.value = newVal;
      }
    }
  });
  const {
    textColorClasses,
    textColorStyles
  } = useTextColor(computed(() => {
    return model.value && !props.error && !props.disabled ? props.color : void 0;
  }));
  const icon = computed(() => {
    var _group$trueIcon$value, _group$falseIcon$valu;
    return model.value ? (_group$trueIcon$value = group == null ? void 0 : group.trueIcon.value) != null ? _group$trueIcon$value : props.trueIcon : (_group$falseIcon$valu = group == null ? void 0 : group.falseIcon.value) != null ? _group$falseIcon$valu : props.falseIcon;
  });
  return {
    group,
    densityClasses,
    trueValue,
    falseValue,
    model,
    textColorClasses,
    textColorStyles,
    icon
  };
}
var VSelectionControl = genericComponent()({
  name: "VSelectionControl",
  directives: {
    Ripple
  },
  inheritAttrs: false,
  props: makeSelectionControlProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      densityClasses,
      group,
      icon,
      model,
      textColorClasses,
      textColorStyles,
      trueValue
    } = useSelectionControl(props);
    const uid = getUid();
    const id = computed(() => props.id || `input-${uid}`);
    const isFocused = ref(false);
    const isFocusVisible = ref(false);
    const input = ref();
    function onFocus(e) {
      isFocused.value = true;
      if (!SUPPORTS_FOCUS_VISIBLE || SUPPORTS_FOCUS_VISIBLE && e.target.matches(":focus-visible")) {
        isFocusVisible.value = true;
      }
    }
    function onBlur() {
      isFocused.value = false;
      isFocusVisible.value = false;
    }
    useRender(() => {
      var _group$type$value, _slots$default, _group$name$value, _slots$input;
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      const type = (_group$type$value = group == null ? void 0 : group.type.value) != null ? _group$type$value : props.type;
      return createVNode("div", {
        "class": ["v-selection-control", {
          "v-selection-control--dirty": model.value,
          "v-selection-control--disabled": props.disabled,
          "v-selection-control--error": props.error,
          "v-selection-control--focused": isFocused.value,
          "v-selection-control--focus-visible": isFocusVisible.value,
          "v-selection-control--inline": (group == null ? void 0 : group.inline.value) || props.inline
        }, densityClasses.value]
      }, [createVNode("div", {
        "class": ["v-selection-control__wrapper", textColorClasses.value]
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), withDirectives(createVNode("div", {
        "class": ["v-selection-control__input"],
        "style": textColorStyles.value
      }, [icon.value && createVNode(VIcon, {
        "icon": icon.value
      }, null), withDirectives(createVNode("input", mergeProps({
        "onUpdate:modelValue": ($event) => model.value = $event,
        "ref": input,
        "disabled": props.disabled,
        "id": id.value,
        "onBlur": onBlur,
        "onFocus": onFocus,
        "readonly": props.readonly,
        "type": type,
        "value": trueValue.value,
        "name": (_group$name$value = group == null ? void 0 : group.name.value) != null ? _group$name$value : props.name,
        "aria-checked": type === "checkbox" ? model.value : void 0
      }, attrs), null), [[vModelDynamic, model.value]]), (_slots$input = slots.input) == null ? void 0 : _slots$input.call(slots, {
        model,
        textColorClasses,
        props: {
          onFocus,
          onBlur,
          id: id.value
        }
      })]), [[resolveDirective("ripple"), props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), createVNode(VLabel, {
        "for": id.value
      }, {
        default: () => [label]
      })]);
    });
    return {
      isFocused,
      input
    };
  }
});
function filterControlProps(props) {
  return pick(props, Object.keys(VSelectionControl.props));
}

// node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
var VCheckbox = defineComponent2({
  name: "VCheckbox",
  inheritAttrs: false,
  props: __spreadProps(__spreadValues(__spreadValues({
    indeterminate: Boolean,
    indeterminateIcon: {
      type: String,
      default: "$checkboxIndeterminate"
    }
  }, makeVInputProps()), makeSelectionControlProps()), {
    falseIcon: {
      type: String,
      default: "$checkboxOff"
    },
    trueIcon: {
      type: String,
      default: "$checkboxOn"
    }
  }),
  emits: {
    "update:indeterminate": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props, "indeterminate");
    const falseIcon = computed(() => {
      return indeterminate.value ? props.indeterminateIcon : props.falseIcon;
    });
    const trueIcon = computed(() => {
      return indeterminate.value ? props.indeterminateIcon : props.trueIcon;
    });
    function onChange() {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    useRender(() => {
      const [inputAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = filterInputProps(props);
      const [controlProps, _2] = filterControlProps(props);
      return createVNode(VInput, mergeProps({
        "class": "v-checkbox"
      }, inputAttrs, inputProps), __spreadProps(__spreadValues({}, slots), {
        default: (_ref2) => {
          let {
            isDisabled,
            isReadonly
          } = _ref2;
          return createVNode(VSelectionControl, mergeProps(controlProps, {
            "type": "checkbox",
            "onUpdate:modelValue": onChange,
            "falseIcon": falseIcon.value,
            "trueIcon": trueIcon.value,
            "aria-checked": indeterminate.value ? "mixed" : void 0,
            "disabled": isDisabled.value,
            "readonly": isReadonly.value
          }, controlAttrs), null);
        }
      }));
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VCode/index.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VCode/VCode.css";
var VCode = createSimpleFunctional("v-code");

// node_modules/vuetify/lib/components/VColorPicker/VColorPicker.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VColorPicker/VColorPicker.css";

// node_modules/vuetify/lib/components/VColorPicker/VColorPickerPreview.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VColorPicker/VColorPickerPreview.css";

// node_modules/vuetify/lib/components/VSlider/VSlider.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSlider/VSlider.css";

// node_modules/vuetify/lib/components/VSlider/VSliderThumb.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSlider/VSliderThumb.css";

// node_modules/vuetify/lib/components/VSlider/slider.mjs
var VSliderSymbol = Symbol.for("vuetify:v-slider");
function getOffset(e, el, direction) {
  const vertical = direction === "vertical";
  const rect = el.getBoundingClientRect();
  const touch = "touches" in e ? e.touches[0] : e;
  return vertical ? touch.clientY - (rect.top + rect.height / 2) : touch.clientX - (rect.left + rect.width / 2);
}
function getPosition(e, position) {
  if ("touches" in e && e.touches.length)
    return e.touches[0][position];
  else if ("changedTouches" in e && e.changedTouches.length)
    return e.changedTouches[0][position];
  else
    return e[position];
}
var makeSliderProps = propsFactory(__spreadValues(__spreadValues({
  disabled: Boolean,
  error: Boolean,
  readonly: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  min: {
    type: [Number, String],
    default: 0
  },
  step: {
    type: [Number, String],
    default: 0
  },
  thumbColor: String,
  thumbLabel: {
    type: [Boolean, String],
    default: void 0,
    validator: (v) => typeof v === "boolean" || v === "always"
  },
  thumbSize: {
    type: [Number, String],
    default: 20
  },
  showTicks: {
    type: [Boolean, String],
    default: false,
    validator: (v) => typeof v === "boolean" || v === "always"
  },
  ticks: {
    type: [Array, Object]
  },
  tickSize: {
    type: [Number, String],
    default: 2
  },
  color: String,
  trackColor: String,
  trackFillColor: String,
  trackSize: {
    type: [Number, String],
    default: 4
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (v) => ["vertical", "horizontal"].includes(v)
  },
  reverse: Boolean
}, makeRoundedProps()), makeElevationProps({
  elevation: 2
})), "slider");
var useSlider = (_ref) => {
  let {
    props,
    handleSliderMouseUp,
    handleMouseMove,
    getActiveThumb
  } = _ref;
  const {
    isRtl
  } = useRtl();
  const isReversed = computed(() => isRtl.value !== props.reverse);
  const horizontalDirection = computed(() => {
    let hd = isRtl.value ? "rtl" : "ltr";
    if (props.reverse) {
      hd = hd === "rtl" ? "ltr" : "rtl";
    }
    return hd;
  });
  const min = computed(() => parseFloat(props.min));
  const max = computed(() => parseFloat(props.max));
  const step = computed(() => props.step > 0 ? parseFloat(props.step) : 0);
  const decimals = computed(() => {
    const trimmedStep = step.value.toString().trim();
    return trimmedStep.includes(".") ? trimmedStep.length - trimmedStep.indexOf(".") - 1 : 0;
  });
  const thumbSize = computed(() => parseInt(props.thumbSize, 10));
  const tickSize = computed(() => parseInt(props.tickSize, 10));
  const trackSize = computed(() => parseInt(props.trackSize, 10));
  const numTicks = computed(() => (max.value - min.value) / step.value);
  const disabled = toRef(props, "disabled");
  const vertical = computed(() => props.direction === "vertical");
  const thumbColor = computed(() => {
    var _props$thumbColor;
    return props.error || props.disabled ? void 0 : (_props$thumbColor = props.thumbColor) != null ? _props$thumbColor : props.color;
  });
  const trackColor = computed(() => {
    var _props$trackColor;
    return props.error || props.disabled ? void 0 : (_props$trackColor = props.trackColor) != null ? _props$trackColor : props.color;
  });
  const trackFillColor = computed(() => {
    var _props$trackFillColor;
    return props.error || props.disabled ? void 0 : (_props$trackFillColor = props.trackFillColor) != null ? _props$trackFillColor : props.color;
  });
  const mousePressed = ref(false);
  const startOffset = ref(0);
  const trackContainerRef = ref();
  const activeThumbRef = ref();
  function roundValue(value) {
    if (step.value <= 0)
      return value;
    const clamped = clamp(value, min.value, max.value);
    const offset = min.value % step.value;
    const newValue = Math.round((clamped - offset) / step.value) * step.value + offset;
    return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));
  }
  function parseMouseMove(e) {
    var _trackContainerRef$va;
    const vertical2 = props.direction === "vertical";
    const start = vertical2 ? "top" : "left";
    const length = vertical2 ? "height" : "width";
    const position2 = vertical2 ? "clientY" : "clientX";
    const {
      [start]: trackStart,
      [length]: trackLength
    } = (_trackContainerRef$va = trackContainerRef.value) == null ? void 0 : _trackContainerRef$va.$el.getBoundingClientRect();
    const clickOffset = getPosition(e, position2);
    let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;
    if (vertical2 || isReversed.value)
      clickPos = 1 - clickPos;
    return roundValue(min.value + clickPos * (max.value - min.value));
  }
  let thumbMoved = false;
  const handleStop = (e) => {
    if (!thumbMoved) {
      startOffset.value = 0;
      handleSliderMouseUp(parseMouseMove(e));
    }
    mousePressed.value = false;
    thumbMoved = false;
    startOffset.value = 0;
  };
  const handleStart = (e) => {
    activeThumbRef.value = getActiveThumb(e);
    if (!activeThumbRef.value)
      return;
    activeThumbRef.value.focus();
    mousePressed.value = true;
    if (activeThumbRef.value.contains(e.target)) {
      thumbMoved = true;
      startOffset.value = getOffset(e, activeThumbRef.value, props.direction);
    } else {
      startOffset.value = 0;
      handleMouseMove(parseMouseMove(e));
    }
  };
  const moveListenerOptions = {
    passive: true,
    capture: true
  };
  function onMouseMove(e) {
    thumbMoved = true;
    handleMouseMove(parseMouseMove(e));
  }
  function onSliderMouseUp(e) {
    e.stopPropagation();
    e.preventDefault();
    handleStop(e);
    window.removeEventListener("mousemove", onMouseMove, moveListenerOptions);
    window.removeEventListener("mouseup", onSliderMouseUp);
  }
  function onSliderTouchend(e) {
    e.stopPropagation();
    e.preventDefault();
    handleStop(e);
    window.removeEventListener("touchmove", onMouseMove, moveListenerOptions);
    window.removeEventListener("touchend", onSliderTouchend);
  }
  function onSliderTouchstart(e) {
    handleStart(e);
    window.addEventListener("touchmove", onMouseMove, moveListenerOptions);
    window.addEventListener("touchend", onSliderTouchend, {
      passive: false
    });
  }
  function onSliderMousedown(e) {
    e.preventDefault();
    handleStart(e);
    window.addEventListener("mousemove", onMouseMove, moveListenerOptions);
    window.addEventListener("mouseup", onSliderMouseUp, {
      passive: false
    });
  }
  const position = (val) => {
    const percentage = (val - min.value) / (max.value - min.value) * 100;
    return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);
  };
  const parsedTicks = computed(() => {
    if (!props.ticks) {
      return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map((t) => {
        const value = min.value + t * step.value;
        return {
          value,
          position: position(value)
        };
      }) : [];
    }
    if (Array.isArray(props.ticks))
      return props.ticks.map((t) => ({
        value: t,
        position: position(t),
        label: t.toString()
      }));
    return Object.keys(props.ticks).map((key) => ({
      value: parseInt(key, 10),
      position: position(parseInt(key, 10)),
      label: props.ticks[key]
    }));
  });
  const hasLabels = computed(() => parsedTicks.value.some((_ref2) => {
    let {
      label
    } = _ref2;
    return !!label;
  }));
  const data = {
    activeThumbRef,
    color: toRef(props, "color"),
    decimals,
    disabled,
    direction: toRef(props, "direction"),
    elevation: toRef(props, "elevation"),
    hasLabels,
    horizontalDirection,
    isReversed,
    min,
    max,
    mousePressed,
    numTicks,
    onSliderMousedown,
    onSliderTouchstart,
    parsedTicks,
    parseMouseMove,
    position,
    readonly: toRef(props, "readonly"),
    rounded: toRef(props, "rounded"),
    roundValue,
    showTicks: toRef(props, "showTicks"),
    startOffset,
    step,
    thumbSize,
    thumbColor,
    thumbLabel: toRef(props, "thumbLabel"),
    ticks: toRef(props, "ticks"),
    tickSize,
    trackColor,
    trackContainerRef,
    trackFillColor,
    trackSize,
    vertical
  };
  provide(VSliderSymbol, data);
  return data;
};

// node_modules/vuetify/lib/components/VSlider/VSliderThumb.mjs
var VSliderThumb = defineComponent2({
  name: "VSliderThumb",
  directives: {
    Ripple: ripple_default
  },
  props: {
    focused: Boolean,
    max: {
      type: Number,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    modelValue: {
      type: Number,
      required: true
    },
    position: {
      type: Number,
      required: true
    }
  },
  emits: {
    "update:modelValue": (v) => true
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const slider = inject(VSliderSymbol);
    if (!slider)
      throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
    const {
      thumbColor,
      step,
      vertical,
      disabled,
      thumbSize,
      thumbLabel,
      direction,
      readonly,
      elevation,
      isReversed,
      horizontalDirection,
      mousePressed,
      decimals
    } = slider;
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(thumbColor);
    const {
      pageup,
      pagedown,
      end,
      home,
      left,
      right,
      down,
      up
    } = keyValues;
    const relevantKeys = [pageup, pagedown, end, home, left, right, down, up];
    const multipliers = computed(() => {
      if (step.value)
        return [1, 2, 3];
      else
        return [1, 5, 10];
    });
    function parseKeydown(e, value) {
      if (!relevantKeys.includes(e.key))
        return;
      e.preventDefault();
      const _step = step.value || 0.1;
      const steps = (props.max - props.min) / _step;
      if ([left, right, down, up].includes(e.key)) {
        const increase = isReversed.value ? [left, up] : [right, up];
        const direction2 = increase.includes(e.key) ? 1 : -1;
        const multiplier = e.shiftKey ? 2 : e.ctrlKey ? 1 : 0;
        value = value + direction2 * _step * multipliers.value[multiplier];
      } else if (e.key === home) {
        value = props.min;
      } else if (e.key === end) {
        value = props.max;
      } else {
        const direction2 = e.key === pagedown ? 1 : -1;
        value = value - direction2 * _step * (steps > 100 ? steps / 10 : 10);
      }
      return Math.max(props.min, Math.min(props.max, value));
    }
    function onKeydown(e) {
      const newValue = parseKeydown(e, props.modelValue);
      newValue != null && emit("update:modelValue", newValue);
    }
    return () => {
      var _slots$thumbLabel, _slots$thumbLabel2;
      const positionPercentage = convertToUnit(vertical.value ? 100 - props.position : props.position, "%");
      const inset = vertical.value ? "block" : "inline";
      const {
        elevationClasses
      } = useElevation(computed(() => !disabled.value ? elevation.value : void 0));
      return createVNode("div", {
        "class": ["v-slider-thumb", {
          "v-slider-thumb--focused": props.focused,
          "v-slider-thumb--pressed": props.focused && mousePressed.value
        }],
        "style": {
          [`inset-${inset}-start`]: `calc(${positionPercentage} - var(--v-slider-thumb-size) / 2)`,
          "--v-slider-thumb-size": convertToUnit(thumbSize.value),
          direction: !vertical.value ? horizontalDirection.value : void 0
        },
        "role": "slider",
        "tabindex": disabled.value ? -1 : 0,
        "aria-valuemin": props.min,
        "aria-valuemax": props.max,
        "aria-valuenow": props.modelValue,
        "aria-readonly": readonly.value,
        "aria-orientation": direction.value,
        "onKeydown": !readonly.value ? onKeydown : void 0
      }, [createVNode("div", {
        "class": ["v-slider-thumb__surface", textColorClasses.value, elevationClasses.value],
        "style": __spreadValues({}, textColorStyles.value)
      }, null), withDirectives(createVNode("div", {
        "class": ["v-slider-thumb__ripple", textColorClasses.value],
        "style": textColorStyles.value
      }, null), [[resolveDirective("ripple"), true, null, {
        circle: true,
        center: true
      }]]), createVNode(VScaleTransition, {
        "origin": "bottom center"
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": "v-slider-thumb__label-container"
        }, [createVNode("div", {
          "class": ["v-slider-thumb__label"]
        }, [createVNode("div", null, [(_slots$thumbLabel = (_slots$thumbLabel2 = slots["thumb-label"]) == null ? void 0 : _slots$thumbLabel2.call(slots, {
          modelValue: props.modelValue
        })) != null ? _slots$thumbLabel : props.modelValue.toFixed(step.value ? decimals.value : 1)])])]), [[vShow, thumbLabel.value && props.focused || thumbLabel.value === "always"]])]
      })]);
    };
  }
});

// node_modules/vuetify/lib/components/VSlider/VSliderTrack.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSlider/VSliderTrack.css";
var VSliderTrack = defineComponent2({
  name: "VSliderTrack",
  props: {
    start: {
      type: Number,
      required: true
    },
    stop: {
      type: Number,
      required: true
    }
  },
  emits: {},
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const slider = inject(VSliderSymbol);
    if (!slider)
      throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
    const {
      trackColor,
      trackFillColor,
      vertical,
      tickSize,
      showTicks,
      trackSize,
      color,
      rounded,
      parsedTicks,
      horizontalDirection
    } = slider;
    const {
      roundedClasses
    } = useRounded(rounded);
    const {
      backgroundColorClasses: trackFillColorClasses,
      backgroundColorStyles: trackFillColorStyles
    } = useBackgroundColor(trackFillColor);
    const {
      backgroundColorClasses: trackColorClasses,
      backgroundColorStyles: trackColorStyles
    } = useBackgroundColor(trackColor);
    const startDir = computed(() => `inset-${vertical.value ? "block-end" : "inline-start"}`);
    const endDir = computed(() => vertical.value ? "height" : "width");
    const backgroundStyles = computed(() => {
      return {
        [startDir.value]: "0%",
        [endDir.value]: "100%"
      };
    });
    const trackFillWidth = computed(() => props.stop - props.start);
    const trackFillStyles = computed(() => {
      return {
        [startDir.value]: convertToUnit(props.start, "%"),
        [endDir.value]: convertToUnit(trackFillWidth.value, "%")
      };
    });
    const computedTicks = computed(() => {
      const ticks = vertical.value ? parsedTicks.value.slice().reverse() : parsedTicks.value;
      return ticks.map((tick, index) => {
        var _slots$tickLabel, _slots$tickLabel2;
        const directionProperty = vertical.value ? "inset-block-end" : "margin-inline-start";
        return createVNode("div", {
          "key": tick.value,
          "class": ["v-slider-track__tick", {
            "v-slider-track__tick--filled": tick.position >= props.start && tick.position <= props.stop
          }],
          "style": {
            [directionProperty]: tick.position > 0 && tick.position < 100 && convertToUnit(tick.position, "%")
          }
        }, [(tick.label || slots["tick-label"]) && createVNode("div", {
          "class": "v-slider-track__tick-label"
        }, [(_slots$tickLabel = (_slots$tickLabel2 = slots["tick-label"]) == null ? void 0 : _slots$tickLabel2.call(slots, {
          tick,
          index
        })) != null ? _slots$tickLabel : tick.label])]);
      });
    });
    return () => {
      return createVNode("div", {
        "class": ["v-slider-track", roundedClasses.value],
        "style": {
          "--v-slider-track-size": convertToUnit(trackSize.value),
          "--v-slider-tick-size": convertToUnit(tickSize.value),
          direction: !vertical.value ? horizontalDirection.value : void 0
        }
      }, [createVNode("div", {
        "class": ["v-slider-track__background", trackColorClasses.value, {
          "v-slider-track__background--opacity": !!color.value || !trackFillColor.value
        }],
        "style": __spreadValues(__spreadValues({}, backgroundStyles.value), trackColorStyles.value)
      }, null), createVNode("div", {
        "class": ["v-slider-track__fill", trackFillColorClasses.value],
        "style": __spreadValues(__spreadValues({}, trackFillStyles.value), trackFillColorStyles.value)
      }, null), showTicks.value && createVNode("div", {
        "class": ["v-slider-track__ticks", {
          "v-slider-track__ticks--always-show": showTicks.value === "always"
        }]
      }, [computedTicks.value])]);
    };
  }
});

// node_modules/vuetify/lib/components/VSlider/VSlider.mjs
var VSlider = defineComponent2({
  name: "VSlider",
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, makeFocusProps()), makeSliderProps()), makeVInputProps()), {
    modelValue: {
      type: [Number, String],
      default: 0
    }
  }),
  emits: {
    "update:focused": (value) => true,
    "update:modelValue": (v) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const thumbContainerRef = ref();
    const {
      min,
      max,
      mousePressed,
      roundValue,
      onSliderMousedown,
      onSliderTouchstart,
      trackContainerRef,
      position,
      hasLabels,
      readonly
    } = useSlider({
      props,
      handleSliderMouseUp: (newValue) => model.value = roundValue(newValue),
      handleMouseMove: (newValue) => model.value = roundValue(newValue),
      getActiveThumb: () => {
        var _thumbContainerRef$va;
        return (_thumbContainerRef$va = thumbContainerRef.value) == null ? void 0 : _thumbContainerRef$va.$el;
      }
    });
    const model = useProxiedModel(props, "modelValue", void 0, (v) => {
      const value = typeof v === "string" ? parseFloat(v) : v == null ? min.value : v;
      return roundValue(value);
    });
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const trackStop = computed(() => position(model.value));
    return () => {
      const [inputProps, _] = filterInputProps(props);
      return createVNode(VInput, mergeProps({
        "class": ["v-slider", {
          "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
          "v-slider--focused": isFocused.value,
          "v-slider--pressed": mousePressed.value,
          "v-slider--disabled": props.disabled
        }]
      }, inputProps, {
        "focused": isFocused.value
      }), __spreadProps(__spreadValues({}, slots), {
        default: (_ref2) => {
          let {
            id
          } = _ref2;
          return createVNode("div", {
            "class": "v-slider__container",
            "onMousedown": !readonly.value ? onSliderMousedown : void 0,
            "onTouchstartPassive": !readonly.value ? onSliderTouchstart : void 0
          }, [createVNode("input", {
            "id": id.value,
            "name": props.name || id.value,
            "disabled": props.disabled,
            "readonly": props.readonly,
            "tabindex": "-1",
            "value": model.value
          }, null), createVNode(VSliderTrack, {
            "ref": trackContainerRef,
            "start": 0,
            "stop": trackStop.value
          }, {
            "tick-label": slots["tick-label"]
          }), createVNode(VSliderThumb, {
            "ref": thumbContainerRef,
            "focused": isFocused.value,
            "min": min.value,
            "max": max.value,
            "modelValue": model.value,
            "onUpdate:modelValue": (v) => model.value = v,
            "position": trackStop.value,
            "elevation": props.elevation,
            "onFocus": focus,
            "onBlur": blur
          }, {
            "thumb-label": slots["thumb-label"]
          })]);
        }
      }));
    };
  }
});

// node_modules/vuetify/lib/components/VColorPicker/util/index.mjs
var _rgba$inputs;
function has(obj, key) {
  return key.every((k) => obj.hasOwnProperty(k));
}
function parseColor(color) {
  var _hsva$a;
  if (!color)
    return null;
  let hsva = null;
  if (typeof color === "string") {
    const hex2 = parseHex(color);
    hsva = HexToHSVA(hex2);
  }
  if (typeof color === "object") {
    if (has(color, ["r", "g", "b"])) {
      hsva = RGBAtoHSVA(color);
    } else if (has(color, ["h", "s", "l"])) {
      hsva = HSLAtoHSVA(color);
    } else if (has(color, ["h", "s", "v"])) {
      hsva = color;
    }
  }
  return hsva != null ? __spreadProps(__spreadValues({}, hsva), {
    a: (_hsva$a = hsva.a) != null ? _hsva$a : 1
  }) : null;
}
function stripAlpha(color, stripAlpha2) {
  if (stripAlpha2) {
    const _a = color, {
      a
    } = _a, rest = __objRest(_a, [
      "a"
    ]);
    return rest;
  }
  return color;
}
function extractColor(color, input) {
  if (input == null || typeof input === "string") {
    const hex2 = HSVAtoHex(color);
    if (color.a === 1)
      return hex2.slice(0, 7);
    else
      return hex2;
  }
  if (typeof input === "object") {
    let converted;
    if (has(input, ["r", "g", "b"]))
      converted = HSVAtoRGBA(color);
    else if (has(input, ["h", "s", "l"]))
      converted = HSVAtoHSLA(color);
    else if (has(input, ["h", "s", "v"]))
      converted = color;
    return stripAlpha(converted, !has(input, ["a"]));
  }
  return color;
}
var nullColor = {
  h: 0,
  s: 0,
  v: 1,
  a: 1
};
var rgba = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "R",
    max: 255,
    step: 1,
    getValue: (c) => Math.round(c.r),
    getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
      r: Number(v)
    })
  }, {
    label: "G",
    max: 255,
    step: 1,
    getValue: (c) => Math.round(c.g),
    getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
      g: Number(v)
    })
  }, {
    label: "B",
    max: 255,
    step: 1,
    getValue: (c) => Math.round(c.b),
    getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
      b: Number(v)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (c) => Math.round(c.a * 100) / 100,
    getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
      a: Number(v)
    })
  }],
  to: HSVAtoRGBA,
  from: RGBAtoHSVA
};
var rgb = __spreadProps(__spreadValues({}, rgba), {
  inputs: (_rgba$inputs = rgba.inputs) == null ? void 0 : _rgba$inputs.slice(0, 3)
});
var hsla = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "H",
    max: 360,
    step: 1,
    getValue: (c) => Math.round(c.h),
    getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
      h: Number(v)
    })
  }, {
    label: "S",
    max: 1,
    step: 0.01,
    getValue: (c) => Math.round(c.s * 100) / 100,
    getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
      s: Number(v)
    })
  }, {
    label: "L",
    max: 1,
    step: 0.01,
    getValue: (c) => Math.round(c.l * 100) / 100,
    getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
      l: Number(v)
    })
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (c) => Math.round(c.a * 100) / 100,
    getColor: (c, v) => __spreadProps(__spreadValues({}, c), {
      a: Number(v)
    })
  }],
  to: HSVAtoHSLA,
  from: HSLAtoHSVA
};
var hsl = __spreadProps(__spreadValues({}, hsla), {
  inputs: hsla.inputs.slice(0, 3)
});
var hexa = {
  inputProps: {
    type: "text"
  },
  inputs: [{
    label: "HEXA",
    getValue: (c) => c,
    getColor: (c, v) => v
  }],
  to: HSVAtoHex,
  from: HexToHSVA
};
var hex = __spreadProps(__spreadValues({}, hexa), {
  inputs: [{
    label: "HEX",
    getValue: (c) => c.slice(0, 7),
    getColor: (c, v) => v
  }]
});
var modes = {
  rgb,
  rgba,
  hsl,
  hsla,
  hex,
  hexa
};

// node_modules/vuetify/lib/components/VColorPicker/VColorPickerPreview.mjs
var VColorPickerPreview = defineComponent2({
  name: "VColorPickerPreview",
  props: {
    color: {
      type: Object
    },
    disabled: Boolean,
    hideAlpha: Boolean
  },
  emits: {
    "update:color": (color) => true
  },
  setup(props, _ref) {
    let {
      emit
    } = _ref;
    return () => {
      var _props$color, _props$color2, _props$color4;
      return createVNode("div", {
        "class": ["v-color-picker-preview", {
          "v-color-picker-preview--hide-alpha": props.hideAlpha
        }]
      }, [createVNode("div", {
        "class": "v-color-picker-preview__dot"
      }, [createVNode("div", {
        "style": {
          background: HSVAtoCSS((_props$color = props.color) != null ? _props$color : nullColor)
        }
      }, null)]), createVNode("div", {
        "class": "v-color-picker-preview__sliders"
      }, [createVNode(VSlider, {
        "class": "v-color-picker-preview__track v-color-picker-preview__hue",
        "modelValue": (_props$color2 = props.color) == null ? void 0 : _props$color2.h,
        "onUpdate:modelValue": (h) => {
          var _props$color3;
          return emit("update:color", __spreadProps(__spreadValues({}, (_props$color3 = props.color) != null ? _props$color3 : nullColor), {
            h
          }));
        },
        "step": 0,
        "min": 0,
        "max": 360,
        "disabled": props.disabled,
        "thumbSize": 14,
        "trackSize": 8,
        "trackFillColor": "white",
        "hideDetails": true
      }, null), !props.hideAlpha && createVNode(VSlider, {
        "class": "v-color-picker-preview__track v-color-picker-preview__alpha",
        "modelValue": (_props$color4 = props.color) == null ? void 0 : _props$color4.a,
        "onUpdate:modelValue": (a) => {
          var _props$color5;
          return emit("update:color", __spreadProps(__spreadValues({}, (_props$color5 = props.color) != null ? _props$color5 : nullColor), {
            a
          }));
        },
        "step": 0,
        "min": 0,
        "max": 1,
        "disabled": props.disabled,
        "thumbSize": 14,
        "trackSize": 8,
        "trackFillColor": "white",
        "hideDetails": true
      }, null)])]);
    };
  }
});

// node_modules/vuetify/lib/components/VColorPicker/VColorPickerCanvas.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VColorPicker/VColorPickerCanvas.css";
var VColorPickerCanvas = defineComponent2({
  name: "VColorPickerCanvas",
  props: {
    color: {
      type: Object
    },
    disabled: Boolean,
    dotSize: {
      type: [Number, String],
      default: 10
    },
    height: {
      type: [Number, String],
      default: 150
    },
    width: {
      type: [Number, String],
      default: 300
    }
  },
  emits: {
    "update:color": (color) => true,
    "update:position": (hue) => true
  },
  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const isInteracting = ref(false);
    const isOutsideUpdate = ref(false);
    const dotPosition = ref({
      x: 0,
      y: 0
    });
    const dotStyles = computed(() => {
      const {
        x,
        y
      } = dotPosition.value;
      const radius = parseInt(props.dotSize, 10) / 2;
      return {
        width: convertToUnit(props.dotSize),
        height: convertToUnit(props.dotSize),
        transform: `translate(${convertToUnit(x - radius)}, ${convertToUnit(y - radius)})`
      };
    });
    const canvasRef = ref();
    function updateDotPosition(x, y, rect) {
      const {
        left,
        top,
        width,
        height
      } = rect;
      dotPosition.value = {
        x: clamp(x - left, 0, width),
        y: clamp(y - top, 0, height)
      };
    }
    function handleClick(e) {
      if (props.disabled || !canvasRef.value)
        return;
      updateDotPosition(e.clientX, e.clientY, canvasRef.value.getBoundingClientRect());
    }
    function handleMouseDown(e) {
      e.preventDefault();
      if (props.disabled)
        return;
      isInteracting.value = true;
      window.addEventListener("mousemove", handleMouseMove);
      window.addEventListener("mouseup", handleMouseUp);
      window.addEventListener("touchmove", handleMouseMove);
      window.addEventListener("touchend", handleMouseUp);
    }
    function handleMouseMove(e) {
      if (props.disabled || !canvasRef.value)
        return;
      isInteracting.value = true;
      const coords = getEventCoordinates(e);
      updateDotPosition(coords.clientX, coords.clientY, canvasRef.value.getBoundingClientRect());
    }
    function handleMouseUp() {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
      window.removeEventListener("touchmove", handleMouseMove);
      window.removeEventListener("touchend", handleMouseUp);
    }
    watch(dotPosition, () => {
      var _props$color$h, _props$color, _props$color$a, _props$color2;
      if (isOutsideUpdate.value) {
        isOutsideUpdate.value = false;
        return;
      }
      if (!canvasRef.value)
        return;
      const {
        width,
        height
      } = canvasRef.value.getBoundingClientRect();
      const {
        x,
        y
      } = dotPosition.value;
      emit("update:color", {
        h: (_props$color$h = (_props$color = props.color) == null ? void 0 : _props$color.h) != null ? _props$color$h : 0,
        s: clamp(x, 0, width) / width,
        v: 1 - clamp(y, 0, height) / height,
        a: (_props$color$a = (_props$color2 = props.color) == null ? void 0 : _props$color2.a) != null ? _props$color$a : 1
      });
    });
    function updateCanvas() {
      var _props$color$h2, _props$color3;
      if (!canvasRef.value)
        return;
      const canvas = canvasRef.value;
      const ctx = canvas.getContext("2d");
      if (!ctx)
        return;
      const saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      saturationGradient.addColorStop(0, "hsla(0, 0%, 100%, 1)");
      saturationGradient.addColorStop(1, `hsla(${(_props$color$h2 = (_props$color3 = props.color) == null ? void 0 : _props$color3.h) != null ? _props$color$h2 : 0}, 100%, 50%, 1)`);
      ctx.fillStyle = saturationGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      valueGradient.addColorStop(0, "hsla(0, 0%, 100%, 0)");
      valueGradient.addColorStop(1, "hsla(0, 0%, 0%, 1)");
      ctx.fillStyle = valueGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    watch(() => {
      var _props$color4;
      return (_props$color4 = props.color) == null ? void 0 : _props$color4.h;
    }, updateCanvas, {
      immediate: true
    });
    watch(() => props.color, () => {
      if (isInteracting.value) {
        isInteracting.value = false;
        return;
      }
      if (!props.color)
        return;
      isOutsideUpdate.value = true;
      dotPosition.value = {
        x: props.color.s * parseInt(props.width, 10),
        y: (1 - props.color.v) * parseInt(props.height, 10)
      };
    }, {
      deep: true,
      immediate: true
    });
    onMounted(() => updateCanvas());
    return () => createVNode("div", {
      "class": "v-color-picker-canvas",
      "style": {
        width: convertToUnit(props.width),
        height: convertToUnit(props.height)
      },
      "onClick": handleClick,
      "onMousedown": handleMouseDown,
      "onTouchstart": handleMouseDown
    }, [createVNode("canvas", {
      "ref": canvasRef,
      "width": props.width,
      "height": props.height
    }, null), createVNode("div", {
      "class": ["v-color-picker-canvas__dot", {
        "v-color-picker-canvas__dot--disabled": props.disabled
      }],
      "style": dotStyles.value
    }, null)]);
  }
});

// node_modules/vuetify/lib/components/VColorPicker/VColorPickerEdit.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VColorPicker/VColorPickerEdit.css";
var VColorPickerInput = (_ref) => {
  let _a = _ref, {
    label
  } = _a, rest = __objRest(_a, [
    "label"
  ]);
  return createVNode("div", {
    "class": "v-color-picker-edit__input"
  }, [createVNode("input", rest, null), createVNode("span", null, [label])]);
};
var VColorPickerEdit = defineComponent2({
  name: "VColorPickerEdit",
  props: {
    color: Object,
    disabled: Boolean,
    mode: {
      type: String,
      default: "rgba",
      validator: (v) => Object.keys(modes).includes(v)
    },
    modes: {
      type: Array,
      default: () => Object.keys(modes),
      validator: (v) => Array.isArray(v) && v.every((m) => Object.keys(modes).includes(m))
    }
  },
  emits: {
    "update:color": (color) => true,
    "update:mode": (mode) => true
  },
  setup(props, _ref2) {
    let {
      emit
    } = _ref2;
    const enabledModes = computed(() => {
      return props.modes.map((key) => __spreadProps(__spreadValues({}, modes[key]), {
        name: key
      }));
    });
    const inputs = computed(() => {
      var _mode$inputs;
      const mode = enabledModes.value.find((m) => m.name === props.mode);
      if (!mode)
        return [];
      const color = props.color ? mode.to(props.color) : {};
      return (_mode$inputs = mode.inputs) == null ? void 0 : _mode$inputs.map((_ref3) => {
        let _a = _ref3, {
          getValue,
          getColor
        } = _a, inputProps = __objRest(_a, [
          "getValue",
          "getColor"
        ]);
        return __spreadProps(__spreadValues(__spreadValues({}, mode.inputProps), inputProps), {
          disabled: props.disabled,
          value: getValue(color),
          onChange: (e) => {
            const target = e.target;
            if (!target)
              return;
            emit("update:color", mode.from(getColor(color, target.value)));
          }
        });
      });
    });
    return () => {
      var _inputs$value;
      return createVNode("div", {
        "class": "v-color-picker-edit"
      }, [(_inputs$value = inputs.value) == null ? void 0 : _inputs$value.map((props2) => createVNode(VColorPickerInput, props2, null)), enabledModes.value.length > 1 && createVNode(VBtn, {
        "icon": "$unfold",
        "size": "x-small",
        "variant": "plain",
        "onClick": () => {
          const mi = enabledModes.value.findIndex((m) => m.name === props.mode);
          emit("update:mode", enabledModes.value[(mi + 1) % enabledModes.value.length].name);
        }
      }, null)]);
    };
  }
});

// node_modules/vuetify/lib/components/VColorPicker/VColorPickerSwatches.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VColorPicker/VColorPickerSwatches.css";

// node_modules/vuetify/lib/util/colors.mjs
var red = Object.freeze({
  base: "#f44336",
  lighten5: "#ffebee",
  lighten4: "#ffcdd2",
  lighten3: "#ef9a9a",
  lighten2: "#e57373",
  lighten1: "#ef5350",
  darken1: "#e53935",
  darken2: "#d32f2f",
  darken3: "#c62828",
  darken4: "#b71c1c",
  accent1: "#ff8a80",
  accent2: "#ff5252",
  accent3: "#ff1744",
  accent4: "#d50000"
});
var pink = Object.freeze({
  base: "#e91e63",
  lighten5: "#fce4ec",
  lighten4: "#f8bbd0",
  lighten3: "#f48fb1",
  lighten2: "#f06292",
  lighten1: "#ec407a",
  darken1: "#d81b60",
  darken2: "#c2185b",
  darken3: "#ad1457",
  darken4: "#880e4f",
  accent1: "#ff80ab",
  accent2: "#ff4081",
  accent3: "#f50057",
  accent4: "#c51162"
});
var purple = Object.freeze({
  base: "#9c27b0",
  lighten5: "#f3e5f5",
  lighten4: "#e1bee7",
  lighten3: "#ce93d8",
  lighten2: "#ba68c8",
  lighten1: "#ab47bc",
  darken1: "#8e24aa",
  darken2: "#7b1fa2",
  darken3: "#6a1b9a",
  darken4: "#4a148c",
  accent1: "#ea80fc",
  accent2: "#e040fb",
  accent3: "#d500f9",
  accent4: "#aa00ff"
});
var deepPurple = Object.freeze({
  base: "#673ab7",
  lighten5: "#ede7f6",
  lighten4: "#d1c4e9",
  lighten3: "#b39ddb",
  lighten2: "#9575cd",
  lighten1: "#7e57c2",
  darken1: "#5e35b1",
  darken2: "#512da8",
  darken3: "#4527a0",
  darken4: "#311b92",
  accent1: "#b388ff",
  accent2: "#7c4dff",
  accent3: "#651fff",
  accent4: "#6200ea"
});
var indigo = Object.freeze({
  base: "#3f51b5",
  lighten5: "#e8eaf6",
  lighten4: "#c5cae9",
  lighten3: "#9fa8da",
  lighten2: "#7986cb",
  lighten1: "#5c6bc0",
  darken1: "#3949ab",
  darken2: "#303f9f",
  darken3: "#283593",
  darken4: "#1a237e",
  accent1: "#8c9eff",
  accent2: "#536dfe",
  accent3: "#3d5afe",
  accent4: "#304ffe"
});
var blue = Object.freeze({
  base: "#2196f3",
  lighten5: "#e3f2fd",
  lighten4: "#bbdefb",
  lighten3: "#90caf9",
  lighten2: "#64b5f6",
  lighten1: "#42a5f5",
  darken1: "#1e88e5",
  darken2: "#1976d2",
  darken3: "#1565c0",
  darken4: "#0d47a1",
  accent1: "#82b1ff",
  accent2: "#448aff",
  accent3: "#2979ff",
  accent4: "#2962ff"
});
var lightBlue = Object.freeze({
  base: "#03a9f4",
  lighten5: "#e1f5fe",
  lighten4: "#b3e5fc",
  lighten3: "#81d4fa",
  lighten2: "#4fc3f7",
  lighten1: "#29b6f6",
  darken1: "#039be5",
  darken2: "#0288d1",
  darken3: "#0277bd",
  darken4: "#01579b",
  accent1: "#80d8ff",
  accent2: "#40c4ff",
  accent3: "#00b0ff",
  accent4: "#0091ea"
});
var cyan = Object.freeze({
  base: "#00bcd4",
  lighten5: "#e0f7fa",
  lighten4: "#b2ebf2",
  lighten3: "#80deea",
  lighten2: "#4dd0e1",
  lighten1: "#26c6da",
  darken1: "#00acc1",
  darken2: "#0097a7",
  darken3: "#00838f",
  darken4: "#006064",
  accent1: "#84ffff",
  accent2: "#18ffff",
  accent3: "#00e5ff",
  accent4: "#00b8d4"
});
var teal = Object.freeze({
  base: "#009688",
  lighten5: "#e0f2f1",
  lighten4: "#b2dfdb",
  lighten3: "#80cbc4",
  lighten2: "#4db6ac",
  lighten1: "#26a69a",
  darken1: "#00897b",
  darken2: "#00796b",
  darken3: "#00695c",
  darken4: "#004d40",
  accent1: "#a7ffeb",
  accent2: "#64ffda",
  accent3: "#1de9b6",
  accent4: "#00bfa5"
});
var green = Object.freeze({
  base: "#4caf50",
  lighten5: "#e8f5e9",
  lighten4: "#c8e6c9",
  lighten3: "#a5d6a7",
  lighten2: "#81c784",
  lighten1: "#66bb6a",
  darken1: "#43a047",
  darken2: "#388e3c",
  darken3: "#2e7d32",
  darken4: "#1b5e20",
  accent1: "#b9f6ca",
  accent2: "#69f0ae",
  accent3: "#00e676",
  accent4: "#00c853"
});
var lightGreen = Object.freeze({
  base: "#8bc34a",
  lighten5: "#f1f8e9",
  lighten4: "#dcedc8",
  lighten3: "#c5e1a5",
  lighten2: "#aed581",
  lighten1: "#9ccc65",
  darken1: "#7cb342",
  darken2: "#689f38",
  darken3: "#558b2f",
  darken4: "#33691e",
  accent1: "#ccff90",
  accent2: "#b2ff59",
  accent3: "#76ff03",
  accent4: "#64dd17"
});
var lime = Object.freeze({
  base: "#cddc39",
  lighten5: "#f9fbe7",
  lighten4: "#f0f4c3",
  lighten3: "#e6ee9c",
  lighten2: "#dce775",
  lighten1: "#d4e157",
  darken1: "#c0ca33",
  darken2: "#afb42b",
  darken3: "#9e9d24",
  darken4: "#827717",
  accent1: "#f4ff81",
  accent2: "#eeff41",
  accent3: "#c6ff00",
  accent4: "#aeea00"
});
var yellow = Object.freeze({
  base: "#ffeb3b",
  lighten5: "#fffde7",
  lighten4: "#fff9c4",
  lighten3: "#fff59d",
  lighten2: "#fff176",
  lighten1: "#ffee58",
  darken1: "#fdd835",
  darken2: "#fbc02d",
  darken3: "#f9a825",
  darken4: "#f57f17",
  accent1: "#ffff8d",
  accent2: "#ffff00",
  accent3: "#ffea00",
  accent4: "#ffd600"
});
var amber = Object.freeze({
  base: "#ffc107",
  lighten5: "#fff8e1",
  lighten4: "#ffecb3",
  lighten3: "#ffe082",
  lighten2: "#ffd54f",
  lighten1: "#ffca28",
  darken1: "#ffb300",
  darken2: "#ffa000",
  darken3: "#ff8f00",
  darken4: "#ff6f00",
  accent1: "#ffe57f",
  accent2: "#ffd740",
  accent3: "#ffc400",
  accent4: "#ffab00"
});
var orange = Object.freeze({
  base: "#ff9800",
  lighten5: "#fff3e0",
  lighten4: "#ffe0b2",
  lighten3: "#ffcc80",
  lighten2: "#ffb74d",
  lighten1: "#ffa726",
  darken1: "#fb8c00",
  darken2: "#f57c00",
  darken3: "#ef6c00",
  darken4: "#e65100",
  accent1: "#ffd180",
  accent2: "#ffab40",
  accent3: "#ff9100",
  accent4: "#ff6d00"
});
var deepOrange = Object.freeze({
  base: "#ff5722",
  lighten5: "#fbe9e7",
  lighten4: "#ffccbc",
  lighten3: "#ffab91",
  lighten2: "#ff8a65",
  lighten1: "#ff7043",
  darken1: "#f4511e",
  darken2: "#e64a19",
  darken3: "#d84315",
  darken4: "#bf360c",
  accent1: "#ff9e80",
  accent2: "#ff6e40",
  accent3: "#ff3d00",
  accent4: "#dd2c00"
});
var brown = Object.freeze({
  base: "#795548",
  lighten5: "#efebe9",
  lighten4: "#d7ccc8",
  lighten3: "#bcaaa4",
  lighten2: "#a1887f",
  lighten1: "#8d6e63",
  darken1: "#6d4c41",
  darken2: "#5d4037",
  darken3: "#4e342e",
  darken4: "#3e2723"
});
var blueGrey = Object.freeze({
  base: "#607d8b",
  lighten5: "#eceff1",
  lighten4: "#cfd8dc",
  lighten3: "#b0bec5",
  lighten2: "#90a4ae",
  lighten1: "#78909c",
  darken1: "#546e7a",
  darken2: "#455a64",
  darken3: "#37474f",
  darken4: "#263238"
});
var grey = Object.freeze({
  base: "#9e9e9e",
  lighten5: "#fafafa",
  lighten4: "#f5f5f5",
  lighten3: "#eeeeee",
  lighten2: "#e0e0e0",
  lighten1: "#bdbdbd",
  darken1: "#757575",
  darken2: "#616161",
  darken3: "#424242",
  darken4: "#212121"
});
var shades = Object.freeze({
  black: "#000000",
  white: "#ffffff",
  transparent: "transparent"
});
var colors_default = Object.freeze({
  red,
  pink,
  purple,
  deepPurple,
  indigo,
  blue,
  lightBlue,
  cyan,
  teal,
  green,
  lightGreen,
  lime,
  yellow,
  amber,
  orange,
  deepOrange,
  brown,
  blueGrey,
  grey,
  shades
});

// node_modules/vuetify/lib/components/VColorPicker/VColorPickerSwatches.mjs
function parseDefaultColors(colors) {
  return Object.keys(colors).map((key) => {
    const color = colors[key];
    return color.base ? [color.base, color.darken4, color.darken3, color.darken2, color.darken1, color.lighten1, color.lighten2, color.lighten3, color.lighten4, color.lighten5] : [color.black, color.white, color.transparent];
  });
}
var VColorPickerSwatches = defineComponent2({
  name: "VColorPickerSwatches",
  props: {
    swatches: {
      type: Array,
      default: () => parseDefaultColors(colors_default)
    },
    disabled: Boolean,
    color: Object,
    maxHeight: [Number, String]
  },
  emits: {
    "update:color": (color) => true
  },
  setup(props, _ref) {
    let {
      emit
    } = _ref;
    return () => createVNode("div", {
      "class": "v-color-picker-swatches",
      "style": {
        maxHeight: convertToUnit(props.maxHeight)
      }
    }, [createVNode("div", null, [props.swatches.map((swatch) => createVNode("div", {
      "class": "v-color-picker-swatches__swatch"
    }, [swatch.map((color) => {
      const hsva = parseColor(color);
      return createVNode("div", {
        "class": "v-color-picker-swatches__color",
        "onClick": () => hsva && emit("update:color", hsva)
      }, [createVNode("div", {
        "style": {
          background: color
        }
      }, [props.color && deepEqual(props.color, hsva) ? createVNode(VIcon, {
        "size": "x-small",
        "icon": "$success",
        "color": getContrast(color, "#FFFFFF") > 2 ? "white" : "black"
      }, null) : void 0])]);
    })]))])]);
  }
});

// node_modules/vuetify/lib/components/VColorPicker/VColorPicker.mjs
var VColorPicker = defineComponent2({
  name: "VColorPicker",
  inheritAttrs: false,
  props: __spreadValues(__spreadValues(__spreadValues({
    canvasHeight: {
      type: [String, Number],
      default: 150
    },
    disabled: Boolean,
    dotSize: {
      type: [Number, String],
      default: 10
    },
    hideCanvas: Boolean,
    hideSliders: Boolean,
    hideInputs: Boolean,
    mode: {
      type: String,
      default: "rgba",
      validator: (v) => Object.keys(modes).includes(v)
    },
    modes: {
      type: Array,
      default: () => Object.keys(modes),
      validator: (v) => Array.isArray(v) && v.every((m) => Object.keys(modes).includes(m))
    },
    showSwatches: Boolean,
    swatches: Array,
    swatchesMaxHeight: {
      type: [Number, String],
      default: 150
    },
    modelValue: {
      type: [Object, String]
    },
    width: {
      type: [Number, String],
      default: 300
    }
  }, makeElevationProps()), makeRoundedProps()), makeThemeProps()),
  emits: {
    "update:modelValue": (color) => true,
    "update:mode": (mode) => true
  },
  setup(props) {
    const mode = useProxiedModel(props, "mode");
    const lastPickedColor = ref(null);
    const currentColor = useProxiedModel(props, "modelValue", void 0, (v) => {
      let c = parseColor(v);
      if (!c)
        return null;
      if (lastPickedColor.value) {
        c = __spreadProps(__spreadValues({}, c), {
          h: lastPickedColor.value.h
        });
        lastPickedColor.value = null;
      }
      return c;
    }, (v) => {
      if (!v)
        return null;
      return extractColor(v, props.modelValue);
    });
    const updateColor = (hsva) => {
      currentColor.value = hsva;
      lastPickedColor.value = hsva;
    };
    onMounted(() => {
      if (!props.modes.includes(mode.value))
        mode.value = props.modes[0];
    });
    return () => {
      var _currentColor$value;
      return createVNode(VSheet, {
        "rounded": props.rounded,
        "elevation": props.elevation,
        "theme": props.theme,
        "class": ["v-color-picker"],
        "style": {
          "--v-color-picker-color-hsv": HSVAtoCSS(__spreadProps(__spreadValues({}, (_currentColor$value = currentColor.value) != null ? _currentColor$value : nullColor), {
            a: 1
          }))
        },
        "maxWidth": props.width
      }, {
        default: () => [!props.hideCanvas && createVNode(VColorPickerCanvas, {
          "color": currentColor.value,
          "onUpdate:color": updateColor,
          "disabled": props.disabled,
          "dotSize": props.dotSize,
          "width": props.width,
          "height": props.canvasHeight
        }, null), (!props.hideSliders || !props.hideInputs) && createVNode("div", {
          "class": "v-color-picker__controls"
        }, [!props.hideSliders && createVNode(VColorPickerPreview, {
          "color": currentColor.value,
          "onUpdate:color": updateColor,
          "hideAlpha": !mode.value.endsWith("a"),
          "disabled": props.disabled
        }, null), !props.hideInputs && createVNode(VColorPickerEdit, {
          "modes": props.modes,
          "mode": mode.value,
          "onUpdate:mode": (m) => mode.value = m,
          "color": currentColor.value,
          "onUpdate:color": updateColor,
          "disabled": props.disabled
        }, null)]), props.showSwatches && createVNode(VColorPickerSwatches, {
          "color": currentColor.value,
          "onUpdate:color": updateColor,
          "maxHeight": props.swatchesMaxHeight,
          "swatches": props.swatches,
          "disabled": props.disabled
        }, null)]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VCombobox/VCombobox.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VCombobox/VCombobox.css";
function highlightResult2(text, matches, length) {
  if (Array.isArray(matches))
    throw new Error("Multiple matches is not implemented");
  return typeof matches === "number" && ~matches ? createVNode(Fragment, null, [createVNode("span", {
    "class": "v-combobox__unmask"
  }, [text.substr(0, matches)]), createVNode("span", {
    "class": "v-combobox__mask"
  }, [text.substr(matches, length)]), createVNode("span", {
    "class": "v-combobox__unmask"
  }, [text.substr(matches + length)])]) : text;
}
var VCombobox = genericComponent()({
  name: "VCombobox",
  props: __spreadValues(__spreadValues(__spreadValues({
    delimiters: Array
  }, makeFilterProps({
    filterKeys: ["title"]
  })), makeSelectProps({
    hideNoData: true
  })), makeTransitionProps({
    transition: false
  })),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const activator = ref();
    const isFocused = ref(false);
    const isPristine = ref(true);
    const menu = ref(false);
    const selectionIndex = ref(-1);
    const color = computed(() => {
      var _vTextFieldRef$value;
      return (_vTextFieldRef$value = vTextFieldRef.value) == null ? void 0 : _vTextFieldRef$value.color;
    });
    const items = computed(() => props.items.map(genItem));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(color);
    const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v || []), (v) => props.multiple ? v : v[0]);
    const _search = ref("");
    const search = computed({
      get: () => props.multiple ? _search.value : genItem(model.value[0]).value,
      set: (val) => {
        var _props$delimiters;
        if (props.multiple) {
          _search.value = val;
        } else {
          model.value = [val];
        }
        if (val && props.multiple && (_props$delimiters = props.delimiters) != null && _props$delimiters.length) {
          const values = val.split(new RegExp(`(?:${props.delimiters.join("|")})+`));
          if (values.length > 1) {
            values.forEach((v) => {
              v = v.trim();
              if (v)
                select({
                  value: v
                });
            });
            _search.value = "";
          }
        }
        if (!val)
          selectionIndex.value = -1;
        if (isFocused.value)
          menu.value = true;
        isPristine.value = !val;
      }
    });
    const {
      filteredItems
    } = useFilter(props, items, computed(() => isPristine.value ? void 0 : search.value));
    const selections = computed(() => {
      const array = [];
      let index = 0;
      for (const unwrapped of model.value) {
        const item = genItem(unwrapped);
        const found = array.find((selection2) => selection2.value === item.value);
        if (found == null) {
          array.push(__spreadProps(__spreadValues({}, item), {
            index,
            selected: index === selectionIndex.value
          }));
          index++;
        }
      }
      return array;
    });
    const selected = computed(() => selections.value.map((selection2) => selection2.value));
    const selection = computed(() => selections.value[selectionIndex.value]);
    function onClear(e) {
      model.value = [];
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onClickControl() {
      if (props.hideNoData && !filteredItems.value.length)
        return;
      menu.value = true;
    }
    function onKeydown(e) {
      const selectionStart = vTextFieldRef.value.selectionStart;
      const length = selected.value.length;
      if (selectionIndex.value > -1)
        e.preventDefault();
      if (["Enter", "ArrowDown"].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape"].includes(e.key)) {
        menu.value = false;
      }
      if (["Enter", "Escape", "Tab"].includes(e.key)) {
        isPristine.value = true;
      }
      if (!props.multiple)
        return;
      if (["Backspace", "Delete"].includes(e.key)) {
        if (selectionIndex.value < 0) {
          if (e.key === "Backspace" && !search.value) {
            selectionIndex.value = length - 1;
          }
          return;
        }
        select(selection.value);
        nextTick(() => !selection.value && (selectionIndex.value = length - 2));
      }
      if (e.key === "ArrowLeft") {
        if (selectionIndex.value < 0 && selectionStart > 0)
          return;
        const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
        if (selections.value[prev]) {
          selectionIndex.value = prev;
        } else {
          selectionIndex.value = -1;
          vTextFieldRef.value.setSelectionRange(search.value.length, search.value.length);
        }
      }
      if (e.key === "ArrowRight") {
        if (selectionIndex.value < 0)
          return;
        const next = selectionIndex.value + 1;
        if (selections.value[next]) {
          selectionIndex.value = next;
        } else {
          selectionIndex.value = -1;
          vTextFieldRef.value.setSelectionRange(0, 0);
        }
      }
      if (e.key === "Enter") {
        select({
          value: search.value
        });
        search.value = "";
      }
    }
    function onAfterLeave() {
      if (isFocused.value)
        isPristine.value = true;
    }
    function select(item) {
      if (props.multiple) {
        const index = selections.value.findIndex((selection2) => selection2.value === item.value);
        if (index === -1) {
          model.value.push(item.value);
        } else {
          model.value = selected.value.filter((selection2) => selection2 !== item.value);
        }
        search.value = "";
      } else {
        search.value = item.title;
        nextTick(() => {
          menu.value = false;
          isPristine.value = true;
        });
      }
    }
    watch(() => vTextFieldRef.value, (val) => {
      activator.value = val.$el.querySelector(".v-input__control");
    });
    watch(filteredItems, (val) => {
      if (!val.length && props.hideNoData)
        menu.value = false;
    });
    watch(isFocused, (val) => {
      if (val) {
        selectionIndex.value = -1;
      } else {
        menu.value = false;
        if (!props.multiple || !search.value)
          return;
        model.value.push(search.value);
        search.value = "";
      }
    });
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      return createVNode(VTextField, {
        "ref": vTextFieldRef,
        "modelValue": search.value,
        "onUpdate:modelValue": ($event) => search.value = $event,
        "class": ["v-combobox", {
          "v-combobox--active-menu": menu.value,
          "v-combobox--chips": !!props.chips,
          "v-combobox--selecting-index": selectionIndex.value > -1,
          [`v-combobox--${props.multiple ? "multiple" : "single"}`]: true
        }],
        "appendInnerIcon": props.items.length ? props.menuIcon : void 0,
        "dirty": selected.value.length > 0,
        "onClick:clear": onClear,
        "onClick:control": onClickControl,
        "onClick:input": onClickControl,
        "onFocus": () => isFocused.value = true,
        "onBlur": () => isFocused.value = false,
        "onKeydown": onKeydown
      }, __spreadProps(__spreadValues({}, slots), {
        default: () => createVNode(Fragment, null, [activator.value && createVNode(VMenu, {
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": activator.value,
          "contentClass": "v-combobox__content",
          "eager": props.eager,
          "openOnClick": false,
          "transition": props.transition,
          "onAfterLeave": onAfterLeave
        }, {
          default: () => [createVNode(VList, {
            "selected": selected.value,
            "selectStrategy": props.multiple ? "independent" : "single-independent"
          }, {
            default: () => [!filteredItems.value.length && !props.hideNoData && createVNode(VListItem, {
              "title": t(props.noDataText)
            }, null), filteredItems.value.map((_ref2) => {
              let {
                item,
                matches
              } = _ref2;
              return createVNode(VListItem, {
                "value": item.value,
                "onMousedown": (e) => e.preventDefault(),
                "onClick": () => select(item)
              }, {
                title: () => {
                  var _search$value$length, _search$value;
                  return isPristine.value ? item.title : highlightResult2(item.title, matches.title, (_search$value$length = (_search$value = search.value) == null ? void 0 : _search$value.length) != null ? _search$value$length : 0);
                }
              });
            })]
          })]
        }), selections.value.map((selection2, index) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(selection2);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            modelValue: true
          };
          return createVNode("div", {
            "class": ["v-combobox__selection", selection2.selected && ["v-combobox__selection--selected", textColorClasses.value]],
            "style": selection2.selected ? textColorStyles.value : {}
          }, [hasChips && createVNode(VDefaultsProvider, {
            "defaults": {
              VChip: {
                closable: props.closableChips,
                size: "small",
                text: selection2.title
              }
            }
          }, {
            default: () => [slots.chip ? slots.chip({
              props: slotProps,
              selection: selection2
            }) : createVNode(VChip, slotProps, null)]
          }), !hasChips && (slots.selection ? slots.selection({
            selection: selection2
          }) : createVNode("span", {
            "class": "v-combobox__selection-text"
          }, [selection2.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
            "class": "v-combobox__selection-comma"
          }, [createTextVNode(",")])]))]);
        })])
      }));
    });
    return useForwardRef({
      isFocused,
      isPristine,
      menu,
      search,
      selectionIndex,
      filteredItems,
      select
    }, vTextFieldRef);
  }
});

// node_modules/vuetify/lib/components/VDialog/VDialog.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VDialog/VDialog.css";
var VDialog = genericComponent()({
  name: "VDialog",
  inheritAttrs: false,
  props: __spreadValues(__spreadValues({
    fullscreen: Boolean,
    origin: {
      type: String,
      default: "center center"
    },
    retainFocus: {
      type: Boolean,
      default: true
    },
    scrollable: Boolean,
    modelValue: Boolean
  }, makeDimensionProps({
    width: "auto"
  })), makeTransitionProps({
    transition: {
      component: VDialogTransition
    }
  })),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      dimensionStyles
    } = useDimension(props);
    const overlay = ref();
    function onFocusin(e) {
      var _overlay$value;
      const before = e.relatedTarget;
      const after = e.target;
      if (before !== after && (_overlay$value = overlay.value) != null && _overlay$value.contentEl && ![document, overlay.value.contentEl].includes(after) && !overlay.value.contentEl.contains(after)) {
        const focusable = [...overlay.value.contentEl.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter((el) => !el.hasAttribute("disabled"));
        if (!focusable.length)
          return;
        const firstElement = focusable[0];
        const lastElement = focusable[focusable.length - 1];
        if (before === firstElement) {
          lastElement.focus();
        } else {
          firstElement.focus();
        }
      }
    }
    if (IN_BROWSER) {
      watch(() => isActive.value && props.retainFocus, (val) => {
        val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
      }, {
        immediate: true
      });
    }
    watch(isActive, async (val) => {
      await nextTick();
      if (val) {
        var _contentEl;
        (_contentEl = overlay.value.contentEl) == null ? void 0 : _contentEl.focus({
          preventScroll: true
        });
      } else {
        var _activatorEl;
        (_activatorEl = overlay.value.activatorEl) == null ? void 0 : _activatorEl.focus({
          preventScroll: true
        });
      }
    });
    return () => {
      return createVNode(VOverlay, mergeProps({
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "class": ["v-dialog", {
          "v-dialog--fullscreen": props.fullscreen
        }],
        "style": dimensionStyles.value,
        "transition": props.transition,
        "ref": overlay,
        "aria-role": "dialog",
        "aria-modal": "true",
        "activatorProps": {
          "aria-haspopup": "dialog",
          "aria-expanded": String(isActive.value)
        }
      }, attrs), {
        default: slots.default,
        activator: slots.activator
      });
    };
  }
});

// node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanels.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanel.css";
var VExpansionPanelSymbol = Symbol.for("vuetify:v-expansion-panel");
var allowedVariants = ["default", "accordion", "inset", "popout"];
var VExpansionPanels = defineComponent2({
  name: "VExpansionPanels",
  props: __spreadValues(__spreadValues(__spreadValues({
    color: String,
    variant: {
      type: String,
      default: "default",
      validator: (v) => allowedVariants.includes(v)
    }
  }, makeGroupProps()), makeTagProps()), makeThemeProps()),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useGroup(props, VExpansionPanelSymbol);
    const {
      themeClasses
    } = provideTheme(props);
    const variantClass = computed(() => props.variant && `v-expansion-panels--variant-${props.variant}`);
    provideDefaults({
      VExpansionPanel: {
        color: toRef(props, "color")
      }
    });
    useRender(() => createVNode(props.tag, {
      "class": ["v-expansion-panels", themeClasses.value, variantClass.value]
    }, slots));
    return {};
  }
});

// node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanelTitle.mjs
var makeVExpansionPanelTitleProps = propsFactory({
  color: String,
  expandIcon: {
    type: String,
    default: "$expand"
  },
  collapseIcon: {
    type: String,
    default: "$collapse"
  },
  hideActions: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: false
  }
});
var VExpansionPanelTitle = defineComponent2({
  name: "VExpansionPanelTitle",
  directives: {
    Ripple
  },
  props: __spreadValues({}, makeVExpansionPanelTitleProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const expansionPanel = inject(VExpansionPanelSymbol);
    if (!expansionPanel)
      throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props, "color");
    const slotProps = computed(() => ({
      collapseIcon: props.collapseIcon,
      disabled: expansionPanel.disabled.value,
      expanded: expansionPanel.isSelected.value,
      expandIcon: props.expandIcon
    }));
    useRender(() => {
      var _slots$default;
      return withDirectives(createVNode("button", {
        "class": ["v-expansion-panel-title", {
          "v-expansion-panel-title--active": expansionPanel.isSelected.value
        }, backgroundColorClasses.value],
        "style": backgroundColorStyles.value,
        "type": "button",
        "tabindex": expansionPanel.disabled.value ? -1 : void 0,
        "disabled": expansionPanel.disabled.value,
        "aria-expanded": expansionPanel.isSelected.value,
        "onClick": expansionPanel.toggle
      }, [createVNode("div", {
        "class": "v-expansion-panel-title__overlay"
      }, null), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, slotProps.value), !props.hideActions && createVNode("div", {
        "class": "v-expansion-panel-title__icon"
      }, [slots.actions ? slots.actions(slotProps.value) : createVNode(VIcon, {
        "icon": expansionPanel.isSelected.value ? props.collapseIcon : props.expandIcon
      }, null)])]), [[resolveDirective("ripple"), props.ripple]]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanelText.mjs
var VExpansionPanelText = defineComponent2({
  name: "VExpansionPanelText",
  props: __spreadValues({}, makeLazyProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const expansionPanel = inject(VExpansionPanelSymbol);
    if (!expansionPanel)
      throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
    const {
      hasContent,
      onAfterLeave
    } = useLazy(props, expansionPanel.isSelected);
    useRender(() => {
      var _slots$default;
      return createVNode(VExpandTransition, {
        "onAfterLeave": onAfterLeave
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": "v-expansion-panel-text"
        }, [slots.default && hasContent.value && createVNode("div", {
          "class": "v-expansion-panel-text__wrapper"
        }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)])]), [[vShow, expansionPanel.isSelected.value]])]
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VExpansionPanel/VExpansionPanel.mjs
var VExpansionPanel = defineComponent2({
  name: "VExpansionPanel",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    title: String,
    text: String,
    bgColor: String
  }, makeElevationProps()), makeGroupItemProps()), makeLazyProps()), makeRoundedProps()), makeTagProps()), makeVExpansionPanelTitleProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const groupItem = useGroupItem(props, VExpansionPanelSymbol);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props, "bgColor");
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const isDisabled = computed(() => (groupItem == null ? void 0 : groupItem.disabled.value) || props.disabled);
    const isBeforeSelected = computed(() => {
      const index = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
      return !groupItem.isSelected.value && groupItem.group.selected.value.some((id) => groupItem.group.items.value.indexOf(id) - index === 1);
    });
    const isAfterSelected = computed(() => {
      const index = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
      return !groupItem.isSelected.value && groupItem.group.selected.value.some((id) => groupItem.group.items.value.indexOf(id) - index === -1);
    });
    provide(VExpansionPanelSymbol, groupItem);
    useRender(() => {
      var _slots$default;
      const hasText = !!(slots.text || props.text);
      const hasTitle = !!(slots.title || props.title);
      return createVNode(props.tag, {
        "class": ["v-expansion-panel", {
          "v-expansion-panel--active": groupItem.isSelected.value,
          "v-expansion-panel--before-active": isBeforeSelected.value,
          "v-expansion-panel--after-active": isAfterSelected.value,
          "v-expansion-panel--disabled": isDisabled.value
        }, roundedClasses.value, backgroundColorClasses.value],
        "style": backgroundColorStyles.value,
        "aria-expanded": groupItem.isSelected.value
      }, {
        default: () => [createVNode("div", {
          "class": ["v-expansion-panel__shadow", ...elevationClasses.value]
        }, null), hasTitle && createVNode(VExpansionPanelTitle, {
          "collapseIcon": props.collapseIcon,
          "color": props.color,
          "expandIcon": props.expandIcon,
          "hideActions": props.hideActions,
          "ripple": props.ripple
        }, {
          default: () => [slots.title ? slots.title() : props.title]
        }), hasText && createVNode(VExpansionPanelText, {
          "eager": props.eager
        }, {
          default: () => [slots.text ? slots.text() : props.text]
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VFileInput/VFileInput.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VFileInput/VFileInput.css";
var VFileInput = defineComponent2({
  name: "VFileInput",
  inheritAttrs: false,
  props: __spreadValues(__spreadProps(__spreadValues({
    chips: Boolean,
    counter: Boolean,
    counterSizeString: {
      type: String,
      default: "$vuetify.fileInput.counterSize"
    },
    counterString: {
      type: String,
      default: "$vuetify.fileInput.counter"
    },
    multiple: Boolean,
    hint: String,
    persistentHint: Boolean,
    placeholder: String,
    showSize: {
      type: [Boolean, Number],
      default: false,
      validator: (v) => {
        return typeof v === "boolean" || [1e3, 1024].includes(v);
      }
    }
  }, makeVInputProps()), {
    prependIcon: {
      type: String,
      default: "$file"
    },
    modelValue: {
      type: Array,
      default: () => [],
      validator: (val) => {
        return wrapInArray(val).every((v) => v != null && typeof v === "object");
      }
    }
  }), makeVFieldProps({
    clearable: true
  })),
  emits: {
    "click:clear": (e) => true,
    "click:control": (e) => true,
    "update:modelValue": (files) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const model = useProxiedModel(props, "modelValue");
    const base = computed(() => typeof props.showSize !== "boolean" ? props.showSize : void 0);
    const totalBytes = computed(() => {
      var _model$value;
      return ((_model$value = model.value) != null ? _model$value : []).reduce((bytes, _ref2) => {
        let {
          size = 0
        } = _ref2;
        return bytes + size;
      }, 0);
    });
    const totalBytesReadable = computed(() => humanReadableFileSize(totalBytes.value, base.value));
    const fileNames = computed(() => {
      var _model$value2;
      return ((_model$value2 = model.value) != null ? _model$value2 : []).map((file) => {
        const {
          name = "",
          size = 0
        } = file;
        return !props.showSize ? name : `${name} (${humanReadableFileSize(size, base.value)})`;
      });
    });
    const counterValue = computed(() => {
      var _model$value$length, _model$value3;
      const fileCount = (_model$value$length = (_model$value3 = model.value) == null ? void 0 : _model$value3.length) != null ? _model$value$length : 0;
      if (props.showSize)
        return t(props.counterSizeString, fileCount, totalBytesReadable.value);
      else
        return t(props.counterString, fileCount);
    });
    const vInputRef = ref();
    const vFieldRef = ref();
    const isFocused = ref(false);
    const inputRef = ref();
    const messages = computed(() => {
      return props.messages.length ? props.messages : props.persistentHint ? props.hint : "";
    });
    function onFocus() {
      if (inputRef.value !== document.activeElement) {
        var _inputRef$value;
        (_inputRef$value = inputRef.value) == null ? void 0 : _inputRef$value.focus();
      }
      if (!isFocused.value) {
        isFocused.value = true;
      }
    }
    function onControlClick(e) {
      var _inputRef$value2;
      (_inputRef$value2 = inputRef.value) == null ? void 0 : _inputRef$value2.click();
      emit("click:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = [];
        if (inputRef != null && inputRef.value) {
          inputRef.value.value = "";
        }
        emit("click:clear", e);
      });
    }
    useRender(() => {
      const hasCounter = !!(slots.counter || props.counter || counterValue.value);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const [_a] = filterInputProps(props), _b = _a, {
        modelValue: _
      } = _b, inputProps = __objRest(_b, [
        "modelValue"
      ]);
      const [fieldProps] = filterFieldProps(props);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": "v-file-input"
      }, rootAttrs, inputProps, {
        "onClick:prepend": onControlClick,
        "messages": messages.value
      }), __spreadProps(__spreadValues({}, slots), {
        default: (_ref3) => {
          let {
            isDisabled,
            isDirty,
            isReadonly,
            isValid
          } = _ref3;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "prepend-icon": props.prependIcon,
            "onClick:control": onControlClick,
            "onClick:clear": onClear
          }, fieldProps, {
            "active": isDirty.value || isFocused.value,
            "dirty": isDirty.value,
            "focused": isFocused.value,
            "error": isValid.value === false
          }), __spreadProps(__spreadValues({}, slots), {
            default: (_ref4) => {
              let {
                props: _a2
              } = _ref4, _b2 = _a2, {
                class: fieldClass
              } = _b2, slotProps = __objRest(_b2, [
                "class"
              ]);
              return createVNode(Fragment, null, [createVNode("input", mergeProps({
                "ref": inputRef,
                "type": "file",
                "readonly": isReadonly.value,
                "disabled": isDisabled.value,
                "multiple": props.multiple,
                "name": props.name,
                "onClick": (e) => {
                  e.stopPropagation();
                  onFocus();
                },
                "onChange": (e) => {
                  var _target$files;
                  if (!e.target)
                    return;
                  const target = e.target;
                  model.value = [...(_target$files = target.files) != null ? _target$files : []];
                },
                "onFocus": onFocus,
                "onBlur": () => isFocused.value = false
              }, slotProps, inputAttrs), null), model.value.length > 0 && createVNode("div", {
                "class": fieldClass
              }, [slots.selection ? slots.selection({
                fileNames: fileNames.value,
                totalBytes: totalBytes.value,
                totalBytesReadable: totalBytesReadable.value
              }) : props.chips ? fileNames.value.map((text) => createVNode(VChip, {
                "key": text,
                "size": "small",
                "color": props.color
              }, {
                default: () => [text]
              })) : fileNames.value.join(", ")])]);
            }
          }));
        },
        details: hasCounter ? () => createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
          "value": counterValue.value
        }, slots.counter)]) : void 0
      }));
    });
    return useForwardRef({}, vInputRef, vFieldRef, inputRef);
  }
});

// node_modules/vuetify/lib/components/VFooter/VFooter.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VFooter/VFooter.css";
var VFooter = defineComponent2({
  name: "VFooter",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String
  }, makeBorderProps()), makeDimensionProps()), makeElevationProps()), makePositionProps()), makeRoundedProps()), makeTagProps({
    tag: "footer"
  })), makeThemeProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      borderClasses
    } = useBorder(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    return () => createVNode(props.tag, {
      "class": ["v-footer", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value],
      "style": [backgroundColorStyles, dimensionStyles.value, positionStyles.value]
    }, slots);
  }
});

// node_modules/vuetify/lib/components/VForm/VForm.mjs
var VForm = defineComponent2({
  name: "VForm",
  props: __spreadValues({}, makeFormProps()),
  emits: {
    "update:modelValue": (val) => true,
    submit: (e) => true
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const form = createForm(props);
    const formRef = ref();
    function onReset(e) {
      e.preventDefault();
      form.reset();
    }
    function onSubmit(e) {
      e.preventDefault();
      form.validate().then((_ref2) => {
        let {
          valid
        } = _ref2;
        if (valid) {
          emit("submit", e);
        }
      });
    }
    useRender(() => {
      var _slots$default;
      return createVNode("form", {
        "ref": formRef,
        "class": "v-form",
        "novalidate": true,
        "onReset": onReset,
        "onSubmit": onSubmit
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, form)]);
    });
    return form;
  }
});

// node_modules/vuetify/lib/components/VHover/VHover.mjs
var VHover = defineComponent2({
  name: "VHover",
  props: __spreadValues({
    disabled: Boolean,
    modelValue: {
      type: Boolean,
      default: void 0
    }
  }, makeDelayProps()),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isHovering = useProxiedModel(props, "modelValue");
    const {
      runOpenDelay,
      runCloseDelay
    } = useDelay(props, (value) => !props.disabled && (isHovering.value = value));
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
        isHovering: isHovering.value,
        props: {
          onMouseenter: runOpenDelay,
          onMouseleave: runCloseDelay
        }
      });
    };
  }
});

// node_modules/vuetify/lib/components/VItemGroup/VItemGroup.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VItemGroup/VItemGroup.css";
var VItemGroupSymbol = Symbol.for("vuetify:v-item-group");
var VItemGroup = defineComponent2({
  name: "VItemGroup",
  props: __spreadValues(__spreadValues(__spreadValues({}, makeGroupProps({
    selectedClass: "v-item--selected"
  })), makeTagProps()), makeThemeProps()),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      isSelected,
      select,
      next,
      prev,
      selected
    } = useGroup(props, VItemGroupSymbol);
    return () => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-item-group", themeClasses.value]
      }, {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          isSelected,
          select,
          next,
          prev,
          selected: selected.value
        })]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VItemGroup/VItem.mjs
var VItem = genericComponent()({
  name: "VItem",
  props: makeGroupItemProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      isSelected,
      select,
      toggle,
      selectedClass,
      value,
      disabled
    } = useGroupItem(props, VItemGroupSymbol);
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
        isSelected: isSelected.value,
        selectedClass: selectedClass.value,
        select,
        toggle,
        value: value.value,
        disabled: disabled.value
      });
    };
  }
});

// node_modules/vuetify/lib/components/VKbd/index.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VKbd/VKbd.css";
var VKbd = createSimpleFunctional("v-kbd");

// node_modules/vuetify/lib/components/VLayout/VLayout.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VLayout/VLayout.css";
var VLayout = defineComponent2({
  name: "VLayout",
  props: makeLayoutProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      layoutClasses,
      layoutStyles,
      getLayoutItem,
      items,
      layoutRef
    } = createLayout(props);
    useRender(() => {
      var _slots$default;
      return createVNode("div", {
        "ref": layoutRef,
        "class": layoutClasses.value,
        "style": layoutStyles.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    });
    return {
      getLayoutItem,
      items
    };
  }
});

// node_modules/vuetify/lib/components/VLayout/VLayoutItem.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VLayout/VLayoutItem.css";
var VLayoutItem = defineComponent2({
  name: "VLayoutItem",
  props: __spreadValues({
    position: {
      type: String,
      required: true
    },
    size: {
      type: [Number, String],
      default: 300
    },
    modelValue: Boolean
  }, makeLayoutItemProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      layoutItemStyles
    } = useLayoutItem({
      id: props.name,
      priority: computed(() => parseInt(props.priority, 10)),
      position: toRef(props, "position"),
      elementSize: toRef(props, "size"),
      layoutSize: toRef(props, "size"),
      active: toRef(props, "modelValue"),
      absolute: toRef(props, "absolute")
    });
    return () => {
      var _slots$default;
      return createVNode("div", {
        "class": ["v-layout-item"],
        "style": layoutItemStyles.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    };
  }
});

// node_modules/vuetify/lib/components/VLazy/VLazy.mjs
var VLazy = defineComponent2({
  name: "VLazy",
  directives: {
    intersect: intersect_default
  },
  props: __spreadValues(__spreadValues(__spreadValues({
    modelValue: Boolean,
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      })
    }
  }, makeDimensionProps()), makeTagProps()), makeTransitionProps({
    transition: "fade-transition"
  })),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      dimensionStyles
    } = useDimension(props);
    const isActive = useProxiedModel(props, "modelValue");
    function onIntersect(isIntersecting) {
      if (isActive.value)
        return;
      isActive.value = isIntersecting;
    }
    return () => {
      var _slots$default;
      return withDirectives(createVNode(props.tag, {
        "class": "v-lazy",
        "style": dimensionStyles.value
      }, {
        default: () => [isActive.value && createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]
        })]
      }), [[resolveDirective("intersect"), onIntersect, props.options]]);
    };
  }
});

// node_modules/vuetify/lib/components/VLocaleProvider/VLocaleProvider.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VLocaleProvider/VLocaleProvider.css";
var VLocaleProvider = defineComponent2({
  name: "VLocaleProvider",
  props: {
    locale: String,
    fallbackLocale: String,
    messages: Object,
    rtl: {
      type: Boolean,
      default: void 0
    }
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const localeInstance = provideLocale(props);
    const {
      rtlClasses
    } = provideRtl(props, localeInstance);
    return () => {
      var _slots$default;
      return createVNode("div", {
        "class": ["v-locale-provider", rtlClasses.value]
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    };
  }
});

// node_modules/vuetify/lib/composables/hydration.mjs
function useHydration(callback) {
  var _vm$root, _vm$root$appContext, _vm$root$appContext$a;
  if (!IN_BROWSER)
    return;
  const vm = getCurrentInstance("useHydration");
  const rootEl = vm == null ? void 0 : (_vm$root = vm.root) == null ? void 0 : (_vm$root$appContext = _vm$root.appContext) == null ? void 0 : (_vm$root$appContext$a = _vm$root$appContext.app) == null ? void 0 : _vm$root$appContext$a._container;
  return rootEl != null && rootEl.__vue_app__ ? callback() : onMounted(callback);
}

// node_modules/vuetify/lib/components/VNoSsr/VNoSsr.mjs
var VNoSsr = defineComponent2({
  name: "VNoSsr",
  setup(_, _ref) {
    let {
      slots
    } = _ref;
    const show = ref(false);
    useHydration(() => show.value = true);
    return () => {
      var _slots$default;
      return show.value && ((_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots));
    };
  }
});

// node_modules/vuetify/lib/components/VPagination/VPagination.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VPagination/VPagination.css";

// node_modules/vuetify/lib/composables/refs.mjs
function useRefs() {
  const refs = ref([]);
  onBeforeUpdate(() => refs.value = []);
  function updateRef(e, i) {
    refs.value[i] = e;
  }
  return {
    refs,
    updateRef
  };
}

// node_modules/vuetify/lib/components/VPagination/VPagination.mjs
var VPagination = defineComponent2({
  name: "VPagination",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    start: {
      type: [Number, String],
      default: 1
    },
    modelValue: {
      type: Number,
      default: (props) => props.start
    },
    disabled: Boolean,
    length: {
      type: [Number, String],
      default: 1,
      validator: (val) => val % 1 === 0
    },
    totalVisible: [Number, String],
    firstIcon: {
      type: String,
      default: "$first"
    },
    prevIcon: {
      type: String,
      default: "$prev"
    },
    nextIcon: {
      type: String,
      default: "$next"
    },
    lastIcon: {
      type: String,
      default: "$last"
    },
    ariaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.root"
    },
    pageAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.page"
    },
    currentPageAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.currentPage"
    },
    firstAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.first"
    },
    previousAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.previous"
    },
    nextAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.next"
    },
    lastAriaLabel: {
      type: String,
      default: "$vuetify.pagination.ariaLabel.last"
    },
    ellipsis: {
      type: String,
      default: "..."
    },
    showFirstLastPage: Boolean
  }, makeRoundedProps()), makeBorderProps()), makeDensityProps()), makeElevationProps()), makeSizeProps()), makeTagProps({
    tag: "nav"
  })), makeThemeProps()), makeVariantProps({
    variant: "text"
  })),
  emits: {
    "update:modelValue": (value) => true,
    first: (value) => true,
    prev: (value) => true,
    next: (value) => true,
    last: (value) => true
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const page = useProxiedModel(props, "modelValue");
    const {
      t,
      n
    } = useLocale();
    const {
      isRtl
    } = useRtl();
    const {
      themeClasses
    } = provideTheme(props);
    const maxButtons = ref(-1);
    provideDefaults(void 0, {
      scoped: true
    });
    const {
      resizeRef
    } = useResizeObserver((entries) => {
      if (!entries.length)
        return;
      const {
        target,
        contentRect
      } = entries[0];
      const firstItem = target.querySelector(".v-pagination__list > *");
      if (!firstItem)
        return;
      const totalWidth = contentRect.width;
      const itemWidth = firstItem.getBoundingClientRect().width + 10;
      maxButtons.value = Math.max(0, Math.floor((totalWidth - 96) / itemWidth));
    });
    const length = computed(() => parseInt(props.length, 10));
    const start = computed(() => parseInt(props.start, 10));
    const totalVisible = computed(() => {
      var _props$totalVisible;
      if (props.totalVisible)
        return Math.min(parseInt((_props$totalVisible = props.totalVisible) != null ? _props$totalVisible : "", 10), length.value);
      else if (maxButtons.value >= 0)
        return maxButtons.value;
      return length.value;
    });
    const range = computed(() => {
      if (length.value <= 0)
        return [];
      if (totalVisible.value <= 3) {
        return [Math.min(Math.max(start.value, page.value), start.value + length.value)];
      }
      if (props.length <= totalVisible.value) {
        return createRange(length.value, start.value);
      }
      const middle = Math.ceil(totalVisible.value / 2);
      const left = middle;
      const right = length.value - middle;
      if (page.value < left) {
        return [...createRange(Math.max(1, totalVisible.value - 2), start.value), props.ellipsis, length.value];
      } else if (page.value > right) {
        const rangeLength = totalVisible.value - 2;
        const rangeStart = length.value - rangeLength + start.value;
        return [start.value, props.ellipsis, ...createRange(rangeLength, rangeStart)];
      } else {
        const rangeLength = Math.max(1, totalVisible.value - 4);
        const rangeStart = rangeLength === 1 ? page.value : page.value - Math.ceil(rangeLength / 2) + start.value;
        return [start.value, props.ellipsis, ...createRange(rangeLength, rangeStart), props.ellipsis, length.value];
      }
    });
    function setValue(e, value, event) {
      e.preventDefault();
      page.value = value;
      event && emit(event, value);
    }
    const {
      refs,
      updateRef
    } = useRefs();
    provideDefaults({
      VBtn: {
        border: toRef(props, "border"),
        density: toRef(props, "density"),
        size: toRef(props, "size"),
        variant: toRef(props, "variant")
      }
    });
    const items = computed(() => {
      return range.value.map((item, index) => {
        const ref2 = (e) => updateRef(e, index);
        if (typeof item === "string") {
          return {
            isActive: false,
            page: item,
            props: {
              ref: ref2,
              ellipsis: true,
              icon: true,
              disabled: true
            }
          };
        } else {
          const isActive = item === page.value;
          return {
            isActive,
            page: n(item),
            props: {
              ref: ref2,
              ellipsis: false,
              icon: true,
              disabled: !!props.disabled || props.length < 2,
              elevation: props.elevation,
              rounded: props.rounded,
              color: isActive ? props.color : void 0,
              ariaCurrent: isActive,
              ariaLabel: t(isActive ? props.currentPageAriaLabel : props.pageAriaLabel, index + 1),
              onClick: (e) => setValue(e, item)
            }
          };
        }
      });
    });
    const controls = computed(() => {
      const prevDisabled = !!props.disabled || page.value <= start.value;
      const nextDisabled = !!props.disabled || page.value >= start.value + length.value - 1;
      return {
        first: props.showFirstLastPage ? {
          icon: isRtl.value ? props.lastIcon : props.firstIcon,
          onClick: (e) => setValue(e, start.value, "first"),
          disabled: prevDisabled,
          ariaLabel: t(props.firstAriaLabel),
          ariaDisabled: prevDisabled
        } : void 0,
        prev: {
          icon: isRtl.value ? props.nextIcon : props.prevIcon,
          onClick: (e) => setValue(e, page.value - 1, "prev"),
          disabled: prevDisabled,
          ariaLabel: t(props.previousAriaLabel),
          ariaDisabled: prevDisabled
        },
        next: {
          icon: isRtl.value ? props.prevIcon : props.nextIcon,
          onClick: (e) => setValue(e, page.value + 1, "next"),
          disabled: nextDisabled,
          ariaLabel: t(props.nextAriaLabel),
          ariaDisabled: nextDisabled
        },
        last: props.showFirstLastPage ? {
          icon: isRtl.value ? props.firstIcon : props.lastIcon,
          onClick: (e) => setValue(e, start.value + length.value - 1, "last"),
          disabled: nextDisabled,
          ariaLabel: t(props.lastAriaLabel),
          ariaDisabled: nextDisabled
        } : void 0
      };
    });
    function updateFocus() {
      var _refs$value$currentIn;
      const currentIndex = page.value - start.value;
      (_refs$value$currentIn = refs.value[currentIndex]) == null ? void 0 : _refs$value$currentIn.$el.focus();
    }
    function onKeydown(e) {
      if (e.key === keyValues.left && !props.disabled && page.value > props.start) {
        page.value = page.value - 1;
        nextTick(updateFocus);
      } else if (e.key === keyValues.right && !props.disabled && page.value < start.value + length.value - 1) {
        page.value = page.value + 1;
        nextTick(updateFocus);
      }
    }
    return () => createVNode(props.tag, {
      "ref": resizeRef,
      "class": ["v-pagination", themeClasses.value],
      "role": "navigation",
      "aria-label": t(props.ariaLabel),
      "onKeydown": onKeydown,
      "data-test": "v-pagination-root"
    }, {
      default: () => [createVNode("ul", {
        "class": "v-pagination__list"
      }, [props.showFirstLastPage && createVNode("li", {
        "class": "v-pagination__first",
        "data-test": "v-pagination-first"
      }, [slots.first ? slots.first(controls.value.first) : createVNode(VBtn, controls.value.first, null)]), createVNode("li", {
        "class": "v-pagination__prev",
        "data-test": "v-pagination-prev"
      }, [slots.prev ? slots.prev(controls.value.prev) : createVNode(VBtn, controls.value.prev, null)]), items.value.map((item, index) => createVNode("li", {
        "key": `${index}_${item.page}`,
        "class": ["v-pagination__item", {
          "v-pagination__item--is-active": item.isActive
        }],
        "data-test": "v-pagination-item"
      }, [slots.item ? slots.item(item) : createVNode(VBtn, item.props, {
        default: () => [item.page]
      })])), createVNode("li", {
        "class": "v-pagination__next",
        "data-test": "v-pagination-next"
      }, [slots.next ? slots.next(controls.value.next) : createVNode(VBtn, controls.value.next, null)]), props.showFirstLastPage && createVNode("li", {
        "class": "v-pagination__last",
        "data-test": "v-pagination-last"
      }, [slots.last ? slots.last(controls.value.last) : createVNode(VBtn, controls.value.last, null)])])]
    });
  }
});

// node_modules/vuetify/lib/components/VParallax/VParallax.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VParallax/VParallax.css";
function floor(val) {
  return Math.floor(Math.abs(val)) * Math.sign(val);
}
var VParallax = defineComponent2({
  name: "VParallax",
  props: {
    scale: {
      type: [Number, String],
      default: 1.3
    }
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const root = ref();
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    watchEffect(() => {
      var _root$value;
      intersectionRef.value = (_root$value = root.value) == null ? void 0 : _root$value.$el;
    });
    let scrollParent;
    watch(isIntersecting, (val) => {
      if (val) {
        scrollParent = getScrollParent(intersectionRef.value);
        scrollParent = scrollParent === document.scrollingElement ? document : scrollParent;
        scrollParent.addEventListener("scroll", onScroll, {
          passive: true
        });
        onScroll();
      } else {
        scrollParent.removeEventListener("scroll", onScroll);
      }
    });
    onBeforeUnmount(() => {
      var _scrollParent;
      (_scrollParent = scrollParent) == null ? void 0 : _scrollParent.removeEventListener("scroll", onScroll);
    });
    let frame = -1;
    function onScroll() {
      if (!isIntersecting.value)
        return;
      cancelAnimationFrame(frame);
      frame = requestAnimationFrame(() => {
        var _root$value2, _scrollParent$clientH, _scrollParent$scrollT;
        const el = ((_root$value2 = root.value) == null ? void 0 : _root$value2.$el).querySelector(".v-img__img");
        if (!el)
          return;
        const rect = intersectionRef.value.getBoundingClientRect();
        const scrollHeight = (_scrollParent$clientH = scrollParent.clientHeight) != null ? _scrollParent$clientH : window.innerHeight;
        const scrollPos = (_scrollParent$scrollT = scrollParent.scrollTop) != null ? _scrollParent$scrollT : window.scrollY;
        const top = rect.top + scrollPos;
        const progress = (scrollPos + scrollHeight - top) / (rect.height + scrollHeight);
        const translate = floor((rect.height * +props.scale - rect.height) * (-progress + 0.5));
        el.style.setProperty("transform", `translateY(${translate}px) scale(${props.scale})`);
      });
    }
    return () => createVNode(VImg, {
      "class": ["v-parallax", {
        "v-parallax--active": isIntersecting.value
      }],
      "ref": root,
      "cover": true,
      "onLoadstart": onScroll,
      "onLoad": onScroll
    }, slots);
  }
});

// node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.css";
var VProgressCircular = defineComponent2({
  name: "VProgressCircular",
  props: __spreadValues(__spreadValues(__spreadValues({
    bgColor: String,
    color: String,
    indeterminate: [Boolean, String],
    modelValue: {
      type: [Number, String],
      default: 0
    },
    rotate: {
      type: [Number, String],
      default: 0
    },
    width: {
      type: [Number, String],
      default: 4
    }
  }, makeSizeProps()), makeTagProps({
    tag: "div"
  })), makeThemeProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const MAGIC_RADIUS_CONSTANT = 20;
    const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
    const root = ref();
    const {
      themeClasses
    } = provideTheme(props);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    const {
      textColorClasses: underlayColorClasses,
      textColorStyles: underlayColorStyles
    } = useTextColor(toRef(props, "bgColor"));
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    const normalizedValue = computed(() => Math.max(0, Math.min(100, parseFloat(props.modelValue))));
    const width = computed(() => Number(props.width));
    const size = computed(() => {
      return sizeStyles.value ? Number(props.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
    });
    const diameter = computed(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size.value) * 2);
    const strokeWidth = computed(() => width.value / size.value * diameter.value);
    const strokeDashOffset = computed(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
    watchEffect(() => {
      intersectionRef.value = root.value;
      resizeRef.value = root.value;
    });
    return () => createVNode(props.tag, {
      "ref": root,
      "class": ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!props.indeterminate,
        "v-progress-circular--visible": isIntersecting.value,
        "v-progress-circular--disable-shrink": props.indeterminate === "disable-shrink"
      }, themeClasses.value, sizeClasses.value, textColorClasses.value],
      "style": [sizeStyles.value, textColorStyles.value],
      "role": "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value
    }, {
      default: () => [createVNode("svg", {
        "style": {
          transform: `rotate(calc(-90deg + ${Number(props.rotate)}deg))`
        },
        "xmlns": "http://www.w3.org/2000/svg",
        "viewBox": `0 0 ${diameter.value} ${diameter.value}`
      }, [createVNode("circle", {
        "class": ["v-progress-circular__underlay", underlayColorClasses.value],
        "style": underlayColorStyles.value,
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": 0
      }, null), createVNode("circle", {
        "class": "v-progress-circular__overlay",
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": strokeDashOffset.value
      }, null)]), slots.default && createVNode("div", {
        "class": "v-progress-circular__content"
      }, [slots.default({
        value: normalizedValue.value
      })])]
    });
  }
});

// node_modules/vuetify/lib/components/VRadio/VRadio.mjs
var VRadio = defineComponent({
  name: "VRadio",
  props: {
    falseIcon: {
      type: String,
      default: "$radioOff"
    },
    trueIcon: {
      type: String,
      default: "$radioOn"
    }
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(VSelectionControl, {
      "class": "v-radio",
      "trueIcon": props.trueIcon,
      "falseIcon": props.falseIcon,
      "type": "radio"
    }, slots));
    return {};
  }
});

// node_modules/vuetify/lib/components/VRadioGroup/VRadioGroup.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VRadioGroup/VRadioGroup.css";
var VRadioGroup = defineComponent({
  name: "VRadioGroup",
  inheritAttrs: false,
  props: __spreadProps(__spreadValues(__spreadValues({
    height: {
      type: [Number, String],
      default: "auto"
    }
  }, makeVInputProps()), makeSelectionControlProps()), {
    trueIcon: {
      type: String,
      default: "$radioOn"
    },
    falseIcon: {
      type: String,
      default: "$radioOff"
    },
    type: {
      type: String,
      default: "radio"
    }
  }),
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const uid = getUid();
    const id = computed(() => props.id || `radio-group-${uid}`);
    useRender(() => {
      const [inputAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = filterInputProps(props);
      const [controlProps, _2] = filterControlProps(props);
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      return createVNode(VInput, mergeProps({
        "class": "v-radio-group"
      }, inputAttrs, inputProps), __spreadProps(__spreadValues({}, slots), {
        default: (_ref2) => {
          let {
            isDisabled,
            isReadonly
          } = _ref2;
          return createVNode(Fragment, null, [label && createVNode(VLabel, {
            "for": id.value
          }, {
            default: () => [label]
          }), createVNode(VSelectionControlGroup, mergeProps(controlProps, {
            "id": id.value,
            "trueIcon": props.trueIcon,
            "falseIcon": props.falseIcon,
            "type": props.type,
            "disabled": isDisabled.value,
            "readonly": isReadonly.value
          }, controlAttrs), slots)]);
        }
      }));
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VRangeSlider/VRangeSlider.mjs
var VRangeSlider = defineComponent({
  name: "VRangeSlider",
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, makeFocusProps()), makeVInputProps()), makeSliderProps()), {
    strict: Boolean,
    modelValue: {
      type: Array,
      default: () => [0, 0]
    }
  }),
  emits: {
    "update:focused": (value) => true,
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const startThumbRef = ref();
    const stopThumbRef = ref();
    const inputRef = ref();
    function getActiveThumb(e) {
      if (!startThumbRef.value || !stopThumbRef.value)
        return;
      const startOffset = getOffset(e, startThumbRef.value.$el, props.direction);
      const stopOffset = getOffset(e, stopThumbRef.value.$el, props.direction);
      const a = Math.abs(startOffset);
      const b = Math.abs(stopOffset);
      return a < b || a === b && startOffset < 0 ? startThumbRef.value.$el : stopThumbRef.value.$el;
    }
    const {
      min,
      max,
      mousePressed,
      roundValue,
      onSliderMousedown,
      onSliderTouchstart,
      trackContainerRef,
      position,
      hasLabels,
      activeThumbRef
    } = useSlider({
      props,
      handleSliderMouseUp: (newValue) => {
        var _startThumbRef$value;
        model.value = activeThumbRef.value === ((_startThumbRef$value = startThumbRef.value) == null ? void 0 : _startThumbRef$value.$el) ? [newValue, model.value[1]] : [model.value[0], newValue];
      },
      handleMouseMove: (newValue) => {
        var _startThumbRef$value3;
        const [start, stop] = model.value;
        if (!props.strict && start === stop && start !== min.value) {
          var _stopThumbRef$value, _startThumbRef$value2, _activeThumbRef$value;
          activeThumbRef.value = newValue > start ? (_stopThumbRef$value = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value.$el : (_startThumbRef$value2 = startThumbRef.value) == null ? void 0 : _startThumbRef$value2.$el;
          (_activeThumbRef$value = activeThumbRef.value) == null ? void 0 : _activeThumbRef$value.focus();
        }
        if (activeThumbRef.value === ((_startThumbRef$value3 = startThumbRef.value) == null ? void 0 : _startThumbRef$value3.$el)) {
          model.value = [Math.min(newValue, stop), stop];
        } else {
          model.value = [start, Math.max(start, newValue)];
        }
      },
      getActiveThumb
    });
    const model = useProxiedModel(props, "modelValue", void 0, (arr) => {
      if (!arr || !arr.length)
        return [0, 0];
      return arr.map((value) => roundValue(value));
    });
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const trackStart = computed(() => position(model.value[0]));
    const trackStop = computed(() => position(model.value[1]));
    return () => {
      const [inputProps, _] = filterInputProps(props);
      return createVNode(VInput, mergeProps({
        "class": ["v-slider", "v-range-slider", {
          "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
          "v-slider--focused": isFocused.value,
          "v-slider--pressed": mousePressed.value,
          "v-slider--disabled": props.disabled
        }],
        "ref": inputRef
      }, inputProps, {
        "focused": isFocused.value
      }), __spreadProps(__spreadValues({}, slots), {
        default: (_ref2) => {
          var _startThumbRef$value4, _stopThumbRef$value4;
          let {
            id
          } = _ref2;
          return createVNode("div", {
            "class": "v-slider__container",
            "onMousedown": onSliderMousedown,
            "onTouchstartPassive": onSliderTouchstart
          }, [createVNode("input", {
            "id": `${id.value}_start`,
            "name": props.name || id.value,
            "disabled": props.disabled,
            "readonly": props.readonly,
            "tabindex": "-1",
            "value": model.value[0]
          }, null), createVNode("input", {
            "id": `${id.value}_stop`,
            "name": props.name || id.value,
            "disabled": props.disabled,
            "readonly": props.readonly,
            "tabindex": "-1",
            "value": model.value[1]
          }, null), createVNode(VSliderTrack, {
            "ref": trackContainerRef,
            "start": trackStart.value,
            "stop": trackStop.value
          }, {
            "tick-label": slots["tick-label"]
          }), createVNode(VSliderThumb, {
            "ref": startThumbRef,
            "focused": isFocused && activeThumbRef.value === ((_startThumbRef$value4 = startThumbRef.value) == null ? void 0 : _startThumbRef$value4.$el),
            "modelValue": model.value[0],
            "onUpdate:modelValue": (v) => model.value = [v, model.value[1]],
            "onFocus": (e) => {
              var _startThumbRef$value5, _stopThumbRef$value2;
              focus();
              activeThumbRef.value = (_startThumbRef$value5 = startThumbRef.value) == null ? void 0 : _startThumbRef$value5.$el;
              if (model.value[0] === model.value[1] && model.value[1] === min.value && e.relatedTarget !== ((_stopThumbRef$value2 = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value2.$el)) {
                var _startThumbRef$value6, _stopThumbRef$value3;
                (_startThumbRef$value6 = startThumbRef.value) == null ? void 0 : _startThumbRef$value6.$el.blur();
                (_stopThumbRef$value3 = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value3.$el.focus();
              }
            },
            "onBlur": () => {
              blur();
              activeThumbRef.value = void 0;
            },
            "min": min.value,
            "max": model.value[1],
            "position": trackStart.value
          }, {
            "thumb-label": slots["thumb-label"]
          }), createVNode(VSliderThumb, {
            "ref": stopThumbRef,
            "focused": isFocused && activeThumbRef.value === ((_stopThumbRef$value4 = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value4.$el),
            "modelValue": model.value[1],
            "onUpdate:modelValue": (v) => model.value = [model.value[0], v],
            "onFocus": (e) => {
              var _stopThumbRef$value5, _startThumbRef$value7;
              focus();
              activeThumbRef.value = (_stopThumbRef$value5 = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value5.$el;
              if (model.value[0] === model.value[1] && model.value[0] === max.value && e.relatedTarget !== ((_startThumbRef$value7 = startThumbRef.value) == null ? void 0 : _startThumbRef$value7.$el)) {
                var _stopThumbRef$value6, _startThumbRef$value8;
                (_stopThumbRef$value6 = stopThumbRef.value) == null ? void 0 : _stopThumbRef$value6.$el.blur();
                (_startThumbRef$value8 = startThumbRef.value) == null ? void 0 : _startThumbRef$value8.$el.focus();
              }
            },
            "onBlur": () => {
              blur();
              activeThumbRef.value = void 0;
            },
            "min": model.value[0],
            "max": max.value,
            "position": trackStop.value
          }, {
            "thumb-label": slots["thumb-label"]
          })]);
        }
      }));
    };
  }
});

// node_modules/vuetify/lib/components/VRating/VRating.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VRating/VRating.css";
var VRating = genericComponent()({
  name: "VRating",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues({
    name: String,
    itemAriaLabel: {
      type: String,
      default: "$vuetify.rating.ariaLabel.item"
    },
    activeColor: String,
    color: String,
    clearable: Boolean,
    disabled: Boolean,
    emptyIcon: {
      type: String,
      default: "$ratingEmpty"
    },
    fullIcon: {
      type: String,
      default: "$ratingFull"
    },
    halfIncrements: Boolean,
    hover: Boolean,
    length: {
      type: [Number, String],
      default: 5
    },
    readonly: Boolean,
    modelValue: {
      type: Number,
      default: 0
    },
    itemLabels: Array,
    itemLabelPosition: {
      type: String,
      default: "top",
      validator: (v) => ["top", "bottom"].includes(v)
    },
    ripple: Boolean
  }, makeDensityProps()), makeSizeProps()), makeTagProps()), makeThemeProps()),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const {
      themeClasses
    } = provideTheme(props);
    const rating = useProxiedModel(props, "modelValue");
    const range = computed(() => createRange(Number(props.length), 1));
    const increments = computed(() => range.value.flatMap((v) => props.halfIncrements ? [v - 0.5, v] : [v]));
    const hoverIndex = ref(-1);
    const focusIndex = ref(-1);
    const firstRef = ref();
    let isClicking = false;
    const itemState = computed(() => increments.value.map((value) => {
      var _props$activeColor;
      const isHovering = props.hover && hoverIndex.value > -1;
      const isFilled = rating.value >= value;
      const isHovered = hoverIndex.value >= value;
      const isFullIcon = isHovering ? isHovered : isFilled;
      const icon = isFullIcon ? props.fullIcon : props.emptyIcon;
      const activeColor = (_props$activeColor = props.activeColor) != null ? _props$activeColor : props.color;
      const color = isFilled || isHovered ? activeColor : props.color;
      return {
        isFilled,
        isHovered,
        icon,
        color
      };
    }));
    const eventState = computed(() => [0, ...increments.value].map((value) => {
      function onMouseenter() {
        hoverIndex.value = value;
      }
      function onMouseleave() {
        hoverIndex.value = -1;
      }
      function onFocus() {
        if (value === 0 && rating.value === 0) {
          var _firstRef$value;
          (_firstRef$value = firstRef.value) == null ? void 0 : _firstRef$value.focus();
        } else {
          focusIndex.value = value;
        }
      }
      function onBlur() {
        if (!isClicking)
          focusIndex.value = -1;
      }
      function onClick() {
        if (props.disabled || props.readonly)
          return;
        rating.value = rating.value === value && props.clearable ? 0 : value;
      }
      return {
        onMouseenter: props.hover ? onMouseenter : void 0,
        onMouseleave: props.hover ? onMouseleave : void 0,
        onFocus,
        onBlur,
        onClick
      };
    }));
    function onMousedown() {
      isClicking = true;
    }
    function onMouseup() {
      isClicking = false;
    }
    const name = computed(() => {
      var _props$name;
      return (_props$name = props.name) != null ? _props$name : `v-rating-${getUid()}`;
    });
    function VRatingItem(_ref2) {
      var _itemState$value$inde, _itemState$value$inde2;
      let {
        value,
        index,
        showStar = true
      } = _ref2;
      const {
        onMouseenter,
        onMouseleave,
        onFocus,
        onBlur,
        onClick
      } = eventState.value[index + 1];
      const id = `${name.value}-${String(value).replace(".", "-")}`;
      const btnProps = {
        color: (_itemState$value$inde = itemState.value[index]) == null ? void 0 : _itemState$value$inde.color,
        density: props.density,
        disabled: props.disabled,
        icon: (_itemState$value$inde2 = itemState.value[index]) == null ? void 0 : _itemState$value$inde2.icon,
        ripple: props.ripple,
        size: props.size,
        tag: "span",
        variant: "plain"
      };
      return createVNode(Fragment, null, [createVNode("label", {
        "for": id,
        "class": {
          "v-rating__item--half": props.halfIncrements && value % 1 > 0,
          "v-rating__item--full": props.halfIncrements && value % 1 === 0
        },
        "onMousedown": onMousedown,
        "onMouseup": onMouseup,
        "onMouseenter": onMouseenter,
        "onMouseleave": onMouseleave
      }, [createVNode("span", {
        "class": "v-rating__hidden"
      }, [t(props.itemAriaLabel, value, props.length)]), !showStar ? void 0 : slots.item ? slots.item(__spreadProps(__spreadValues({}, itemState.value[index]), {
        props: btnProps,
        value,
        index
      })) : createVNode(VBtn, btnProps, null)]), createVNode("input", {
        "class": "v-rating__hidden",
        "name": name.value,
        "id": id,
        "type": "radio",
        "value": value,
        "checked": rating.value === value,
        "onClick": onClick,
        "onFocus": onFocus,
        "onBlur": onBlur,
        "ref": index === 0 ? firstRef : void 0,
        "readonly": props.readonly,
        "disabled": props.disabled
      }, null)]);
    }
    return () => {
      var _props$itemLabels;
      const hasLabels = !!((_props$itemLabels = props.itemLabels) != null && _props$itemLabels.length) || slots["item-label"];
      return createVNode(props.tag, {
        "class": ["v-rating", {
          "v-rating--hover": props.hover,
          "v-rating--readonly": props.readonly
        }, themeClasses.value]
      }, {
        default: () => [createVNode(VRatingItem, {
          "value": 0,
          "index": -1,
          "showStar": false
        }, null), range.value.map((value, i) => {
          var _props$itemLabels2, _props$itemLabels3;
          return createVNode("div", {
            "class": "v-rating__wrapper"
          }, [!hasLabels ? void 0 : slots["item-label"] ? slots["item-label"]({
            value,
            index: i,
            label: (_props$itemLabels2 = props.itemLabels) == null ? void 0 : _props$itemLabels2[i]
          }) : (_props$itemLabels3 = props.itemLabels) != null && _props$itemLabels3[i] ? createVNode("span", null, [props.itemLabels[i]]) : createVNode("span", null, [createTextVNode("\xA0")]), createVNode("div", {
            "class": ["v-rating__item", {
              "v-rating__item--focused": Math.ceil(focusIndex.value) === value
            }]
          }, [props.halfIncrements ? createVNode(Fragment, null, [createVNode(VRatingItem, {
            "value": value - 0.5,
            "index": i * 2
          }, null), createVNode(VRatingItem, {
            "value": value,
            "index": i * 2 + 1
          }, null)]) : createVNode(VRatingItem, {
            "value": value,
            "index": i
          }, null)])]);
        })]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VSlideGroup/VSlideGroup.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSlideGroup/VSlideGroup.css";

// node_modules/vuetify/lib/components/VSlideGroup/helpers.mjs
function bias(val) {
  const c = 0.501;
  const x = Math.abs(val);
  return Math.sign(val) * (x / ((1 / c - 2) * (1 - x) + 1));
}
function calculateUpdatedOffset(_ref) {
  let {
    selectedElement,
    containerSize,
    contentSize,
    isRtl,
    currentScrollOffset,
    isHorizontal
  } = _ref;
  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
  const adjustedOffsetStart = isRtl ? contentSize - offsetStart - clientSize : offsetStart;
  if (isRtl) {
    currentScrollOffset = -currentScrollOffset;
  }
  const totalSize = containerSize + currentScrollOffset;
  const itemOffset = clientSize + adjustedOffsetStart;
  const additionalOffset = clientSize * 0.4;
  if (adjustedOffsetStart <= currentScrollOffset) {
    currentScrollOffset = Math.max(adjustedOffsetStart - additionalOffset, 0);
  } else if (totalSize <= itemOffset) {
    currentScrollOffset = Math.min(currentScrollOffset - (totalSize - itemOffset - additionalOffset), contentSize - containerSize);
  }
  return isRtl ? -currentScrollOffset : currentScrollOffset;
}
function calculateCenteredOffset(_ref2) {
  let {
    selectedElement,
    containerSize,
    contentSize,
    isRtl,
    isHorizontal
  } = _ref2;
  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
  if (isRtl) {
    const offsetCentered = contentSize - offsetStart - clientSize / 2 - containerSize / 2;
    return -Math.min(contentSize - containerSize, Math.max(0, offsetCentered));
  } else {
    const offsetCentered = offsetStart + clientSize / 2 - containerSize / 2;
    return Math.min(contentSize - containerSize, Math.max(0, offsetCentered));
  }
}

// node_modules/vuetify/lib/components/VSlideGroup/VSlideGroup.mjs
var VSlideGroupSymbol = Symbol.for("vuetify:v-slide-group");
var VSlideGroup = defineComponent2({
  name: "VSlideGroup",
  props: __spreadValues(__spreadValues({
    activeClass: {
      type: String,
      default: "v-slide-item--active"
    },
    centerActive: Boolean,
    direction: {
      type: String,
      default: "horizontal"
    },
    symbol: {
      type: null,
      default: VSlideGroupSymbol
    },
    nextIcon: {
      type: String,
      default: "$next"
    },
    prevIcon: {
      type: String,
      default: "$prev"
    },
    showArrows: {
      type: [Boolean, String],
      validator: (v) => typeof v === "boolean" || ["always", "desktop", "mobile"].includes(v)
    }
  }, makeTagProps()), makeGroupProps()),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      isRtl
    } = useRtl();
    const {
      mobile
    } = useDisplay();
    const group = useGroup(props, props.symbol);
    const isOverflowing = ref(false);
    const scrollOffset = ref(0);
    const containerSize = ref(0);
    const contentSize = ref(0);
    const isHorizontal = computed(() => props.direction === "horizontal");
    const {
      resizeRef: containerRef,
      contentRect: containerRect
    } = useResizeObserver();
    const contentRef = ref();
    watchEffect(() => {
      if (!containerRect.value || !contentRef.value)
        return;
      const sizeProperty = isHorizontal.value ? "width" : "height";
      containerSize.value = containerRect.value[sizeProperty];
      contentSize.value = contentRef.value.getBoundingClientRect()[sizeProperty];
      isOverflowing.value = containerSize.value + 1 < contentSize.value;
    });
    watch(group.selected, (selected) => {
      if (!selected.length || !contentRef.value)
        return;
      const index = group.items.value.findIndex((item) => item.id === selected[selected.length - 1]);
      const selectedElement = contentRef.value.children[index];
      if (index === 0 || !isOverflowing.value) {
        scrollOffset.value = 0;
      } else if (props.centerActive) {
        scrollOffset.value = calculateCenteredOffset({
          selectedElement,
          containerSize: containerSize.value,
          contentSize: contentSize.value,
          isRtl: isRtl.value,
          isHorizontal: isHorizontal.value
        });
      } else if (isOverflowing.value) {
        scrollOffset.value = calculateUpdatedOffset({
          selectedElement,
          containerSize: containerSize.value,
          contentSize: contentSize.value,
          isRtl: isRtl.value,
          currentScrollOffset: scrollOffset.value,
          isHorizontal: isHorizontal.value
        });
      }
    });
    const disableTransition = ref(false);
    let startTouch = 0;
    let startOffset = 0;
    function onTouchstart(e) {
      const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
      startOffset = scrollOffset.value;
      startTouch = e.touches[0][sizeProperty];
      disableTransition.value = true;
    }
    function onTouchmove(e) {
      if (!isOverflowing.value)
        return;
      const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
      scrollOffset.value = startOffset + startTouch - e.touches[0][sizeProperty];
    }
    function onTouchend(e) {
      const maxScrollOffset = contentSize.value - containerSize.value;
      if (isRtl.value) {
        if (scrollOffset.value > 0 || !isOverflowing.value) {
          scrollOffset.value = 0;
        } else if (scrollOffset.value <= -maxScrollOffset) {
          scrollOffset.value = -maxScrollOffset;
        }
      } else {
        if (scrollOffset.value < 0 || !isOverflowing.value) {
          scrollOffset.value = 0;
        } else if (scrollOffset.value >= maxScrollOffset) {
          scrollOffset.value = maxScrollOffset;
        }
      }
      disableTransition.value = false;
    }
    function onScroll() {
      containerRef.value && (containerRef.value.scrollLeft = 0);
    }
    const isFocused = ref(false);
    function onFocusin(e) {
      isFocused.value = true;
      if (!isOverflowing.value || !contentRef.value)
        return;
      for (const el of e.composedPath()) {
        for (const item of contentRef.value.children) {
          if (item === el) {
            scrollOffset.value = calculateUpdatedOffset({
              selectedElement: item,
              containerSize: containerSize.value,
              contentSize: contentSize.value,
              isRtl: isRtl.value,
              currentScrollOffset: scrollOffset.value,
              isHorizontal: isHorizontal.value
            });
            return;
          }
        }
      }
    }
    function onFocusout(e) {
      isFocused.value = false;
    }
    function onFocus(e) {
      var _contentRef$value;
      if (!isFocused.value && !(e.relatedTarget && (_contentRef$value = contentRef.value) != null && _contentRef$value.contains(e.relatedTarget)))
        focus();
    }
    function onKeydown(e) {
      if (!contentRef.value)
        return;
      if (e.key === (isHorizontal.value ? "ArrowRight" : "ArrowDown")) {
        focus("next");
      } else if (e.key === (isHorizontal.value ? "ArrowLeft" : "ArrowUp")) {
        focus("prev");
      } else if (e.key === "Home") {
        focus("first");
      } else if (e.key === "End") {
        focus("last");
      }
    }
    function focus(location) {
      if (!contentRef.value)
        return;
      if (!location) {
        var _focusable$;
        contentRef.value.querySelector("[tabindex]");
        const focusable = [...contentRef.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter((el) => !el.hasAttribute("disabled"));
        (_focusable$ = focusable[0]) == null ? void 0 : _focusable$.focus();
      } else if (location === "next") {
        var _contentRef$value$que;
        const el = (_contentRef$value$que = contentRef.value.querySelector(":focus")) == null ? void 0 : _contentRef$value$que.nextElementSibling;
        if (el)
          el.focus();
        else
          focus("first");
      } else if (location === "prev") {
        var _contentRef$value$que2;
        const el = (_contentRef$value$que2 = contentRef.value.querySelector(":focus")) == null ? void 0 : _contentRef$value$que2.previousElementSibling;
        if (el)
          el.focus();
        else
          focus("last");
      } else if (location === "first") {
        var _contentRef$value$fir;
        (_contentRef$value$fir = contentRef.value.firstElementChild) == null ? void 0 : _contentRef$value$fir.focus();
      } else if (location === "last") {
        var _contentRef$value$las;
        (_contentRef$value$las = contentRef.value.lastElementChild) == null ? void 0 : _contentRef$value$las.focus();
      }
    }
    function scrollTo(location) {
      const sign = isRtl.value ? -1 : 1;
      const newAbosluteOffset = sign * scrollOffset.value + (location === "prev" ? -1 : 1) * containerSize.value;
      scrollOffset.value = sign * clamp(newAbosluteOffset, 0, contentSize.value - containerSize.value);
    }
    const contentStyles = computed(() => {
      const scrollAmount = scrollOffset.value <= 0 ? bias(-scrollOffset.value) : scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;
      return {
        transform: `translate${isHorizontal.value ? "X" : "Y"}(${scrollAmount}px)`,
        transition: disableTransition.value ? "none" : "",
        willChange: disableTransition.value ? "transform" : ""
      };
    });
    const slotProps = computed(() => ({
      next: group.next,
      prev: group.prev,
      select: group.select,
      isSelected: group.isSelected
    }));
    const hasAffixes = computed(() => {
      switch (props.showArrows) {
        case "always":
          return true;
        case "desktop":
          return mobile.value;
        case true:
          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;
        case "mobile":
          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;
        default:
          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);
      }
    });
    const hasPrev = computed(() => {
      return hasAffixes.value && scrollOffset.value > 0;
    });
    const hasNext = computed(() => {
      if (!hasAffixes.value)
        return false;
      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;
    });
    useRender(() => {
      var _slots$prev, _slots$prev2, _slots$default, _slots$next, _slots$next2;
      return createVNode(props.tag, {
        "class": ["v-slide-group", {
          "v-slide-group--vertical": !isHorizontal.value,
          "v-slide-group--has-affixes": hasAffixes.value,
          "v-slide-group--is-overflowing": isOverflowing.value
        }],
        "tabindex": isFocused.value || group.selected.value.length ? -1 : 0,
        "onFocus": onFocus
      }, {
        default: () => [hasAffixes.value && createVNode("div", {
          "class": ["v-slide-group__prev", {
            "v-slide-group__prev--disabled": !hasPrev.value
          }],
          "onClick": () => scrollTo("prev")
        }, [(_slots$prev = (_slots$prev2 = slots.prev) == null ? void 0 : _slots$prev2.call(slots, slotProps.value)) != null ? _slots$prev : createVNode(VFadeTransition, null, {
          default: () => [createVNode(VIcon, {
            "icon": props.prevIcon
          }, null)]
        })]), createVNode("div", {
          "ref": containerRef,
          "class": "v-slide-group__container",
          "onScroll": onScroll
        }, [createVNode("div", {
          "ref": contentRef,
          "class": "v-slide-group__content",
          "style": contentStyles.value,
          "onTouchstartPassive": onTouchstart,
          "onTouchmovePassive": onTouchmove,
          "onTouchendPassive": onTouchend,
          "onFocusin": onFocusin,
          "onFocusout": onFocusout,
          "onKeydown": onKeydown
        }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, slotProps.value)])]), hasAffixes.value && createVNode("div", {
          "class": ["v-slide-group__next", {
            "v-slide-group__next--disabled": !hasNext.value
          }],
          "onClick": () => scrollTo("next")
        }, [(_slots$next = (_slots$next2 = slots.next) == null ? void 0 : _slots$next2.call(slots, slotProps.value)) != null ? _slots$next : createVNode(VFadeTransition, null, {
          default: () => [createVNode(VIcon, {
            "icon": props.nextIcon
          }, null)]
        })])]
      });
    });
    return {
      selected: group.selected,
      scrollTo,
      scrollOffset,
      focus
    };
  }
});

// node_modules/vuetify/lib/components/VSlideGroup/VSlideGroupItem.mjs
var VSlideGroupItem = defineComponent2({
  name: "VSlideGroupItem",
  props: __spreadValues({}, makeGroupItemProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const slideGroupItem = useGroupItem(props, VSlideGroupSymbol);
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
        isSelected: slideGroupItem.isSelected.value,
        select: slideGroupItem.select
      });
    };
  }
});

// node_modules/vuetify/lib/components/VSnackbar/VSnackbar.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSnackbar/VSnackbar.css";
var VSnackbar = defineComponent2({
  name: "VSnackbar",
  props: __spreadValues(__spreadValues(__spreadValues({
    app: Boolean,
    centered: Boolean,
    contentClass: {
      type: String,
      default: ""
    },
    multiLine: Boolean,
    timeout: {
      type: [Number, String],
      default: 5e3
    },
    vertical: Boolean,
    modelValue: Boolean
  }, makePositionProps()), makeVariantProps()), makeTransitionProps({
    transition: "v-snackbar-transition"
  })),
  emits: {
    "update:modelValue": (v) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      positionClasses,
      positionStyles
    } = usePosition(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    watch(isActive, startTimeout);
    watch(() => props.timeout, startTimeout);
    onMounted(() => {
      if (isActive.value)
        startTimeout();
    });
    let activeTimeout = -1;
    function startTimeout() {
      window.clearTimeout(activeTimeout);
      const timeout = Number(props.timeout);
      if (!isActive.value || timeout === -1)
        return;
      activeTimeout = window.setTimeout(() => {
        isActive.value = false;
      }, timeout);
    }
    function onPointerenter() {
      window.clearTimeout(activeTimeout);
    }
    useRender(() => {
      var _slots$default, _slots$actions;
      return createVNode("div", {
        "class": ["v-snackbar", {
          "v-snackbar--active": isActive.value,
          "v-snackbar--bottom": props.bottom || !props.top,
          "v-snackbar--centered": props.centered,
          "v-snackbar--end": props.right,
          "v-snackbar--multi-line": props.multiLine && !props.vertical,
          "v-snackbar--start": props.left,
          "v-snackbar--top": props.top,
          "v-snackbar--vertical": props.vertical
        }, positionClasses.value],
        "style": [colorStyles.value, positionStyles.value]
      }, [createVNode(MaybeTransition, {
        "transition": props.transition
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": ["v-snackbar__wrapper", colorClasses.value, variantClasses.value],
          "onPointerenter": onPointerenter,
          "onPointerleave": startTimeout
        }, [genOverlays(false, "v-snackbar"), slots.default && createVNode("div", {
          "class": ["v-snackbar__content", props.contentClass],
          "role": "status",
          "aria-live": "polite"
        }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              variant: "text",
              ripple: false
            }
          }
        }, {
          default: () => [createVNode("div", {
            "class": "v-snackbar__actions"
          }, [(_slots$actions = slots.actions) == null ? void 0 : _slots$actions.call(slots)])]
        })]), [[vShow, isActive.value]])]
      })]);
    });
  }
});

// node_modules/vuetify/lib/components/VSwitch/VSwitch.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSwitch/VSwitch.css";
var VSwitch = defineComponent({
  name: "VSwitch",
  inheritAttrs: false,
  props: __spreadValues(__spreadValues(__spreadValues({
    indeterminate: Boolean,
    inset: Boolean,
    flat: Boolean
  }, makeLoaderProps()), makeVInputProps()), makeSelectionControlProps()),
  emits: {
    "update:indeterminate": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props, "indeterminate");
    const {
      loaderClasses
    } = useLoader(props);
    const loaderColor = computed(() => {
      return typeof props.loading === "string" && props.loading !== "" ? props.loading : props.color;
    });
    function onChange() {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    useRender(() => {
      const [inputAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = filterInputProps(props);
      const [controlProps, _2] = filterControlProps(props);
      const control = ref();
      function onClick() {
        var _control$value, _control$value$input;
        (_control$value = control.value) == null ? void 0 : (_control$value$input = _control$value.input) == null ? void 0 : _control$value$input.click();
      }
      return createVNode(VInput, mergeProps({
        "class": ["v-switch", {
          "v-switch--inset": props.inset
        }, {
          "v-switch--indeterminate": indeterminate.value
        }, loaderClasses.value]
      }, inputAttrs, inputProps), __spreadProps(__spreadValues({}, slots), {
        default: (_ref2) => {
          let {
            isDisabled,
            isReadonly,
            isValid
          } = _ref2;
          return createVNode(VSelectionControl, mergeProps({
            "ref": control
          }, controlProps, {
            "type": "checkbox",
            "onUpdate:modelValue": onChange,
            "aria-checked": indeterminate.value ? "mixed" : void 0,
            "disabled": isDisabled.value,
            "readonly": isReadonly.value
          }, controlAttrs), {
            default: () => createVNode("div", {
              "class": "v-switch__track",
              "onClick": onClick
            }, null),
            input: (_ref3) => {
              let {
                textColorClasses
              } = _ref3;
              return createVNode("div", {
                "class": ["v-switch__thumb", textColorClasses.value]
              }, [props.loading && createVNode(LoaderSlot, {
                "name": "v-switch",
                "active": true,
                "color": isValid.value === false ? void 0 : loaderColor.value
              }, {
                default: (slotProps) => slots.loader ? slots.loader(slotProps) : createVNode(VProgressCircular, {
                  "active": slotProps.isActive,
                  "color": slotProps.color,
                  "indeterminate": true,
                  "size": "16",
                  "width": "2"
                }, null)
              })]);
            }
          });
        }
      }));
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VSystemBar/VSystemBar.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VSystemBar/VSystemBar.css";
var VSystemBar = defineComponent2({
  name: "VSystemBar",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    color: String,
    window: Boolean
  }, makeDimensionProps()), makeElevationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    return () => createVNode(props.tag, {
      "class": ["v-system-bar", {
        "v-system-bar--window": props.window
      }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value],
      "style": [backgroundColorStyles.value, dimensionStyles.value, positionStyles.value]
    }, slots);
  }
});

// node_modules/vuetify/lib/components/VTabs/VTabs.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VTabs/VTabs.css";

// node_modules/vuetify/lib/components/VTabs/VTab.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VTabs/VTab.css";
var VTab = defineComponent2({
  name: "VTab",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues({
    fixed: Boolean,
    icon: [Boolean, String],
    prependIcon: String,
    appendIcon: String,
    stacked: Boolean,
    title: String,
    ripple: {
      type: Boolean,
      default: true
    },
    color: String,
    sliderColor: String,
    hideSlider: Boolean,
    direction: {
      type: String,
      default: "horizontal"
    }
  }, makeTagProps()), makeRouterProps()), makeGroupItemProps({
    selectedClass: "v-tab--selected"
  })), makeThemeProps()),
  setup(props, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      isSelected,
      select,
      selectedClass
    } = useGroupItem(props, VTabsSymbol);
    const {
      textColorClasses: sliderColorClasses,
      textColorStyles: sliderColorStyles
    } = useTextColor(props, "sliderColor");
    const isHorizontal = computed(() => props.direction === "horizontal");
    provideDefaults({
      VBtn: {
        block: toRef(props, "fixed"),
        maxWidth: computed(() => props.fixed ? 300 : void 0),
        color: computed(() => isSelected.value ? props.color : void 0),
        variant: "text",
        rounded: 0
      }
    }, {
      scoped: true
    });
    const rootEl = ref();
    const sliderEl = ref();
    watch(isSelected, (isSelected2) => {
      if (isSelected2) {
        var _rootEl$value, _rootEl$value$$el$par;
        const prevEl = (_rootEl$value = rootEl.value) == null ? void 0 : (_rootEl$value$$el$par = _rootEl$value.$el.parentElement) == null ? void 0 : _rootEl$value$$el$par.querySelector(".v-tab--selected .v-tab__slider");
        const nextEl = sliderEl.value;
        if (!prevEl || !nextEl)
          return;
        const color = getComputedStyle(prevEl).color;
        const prevBox = prevEl.getBoundingClientRect();
        const nextBox = nextEl.getBoundingClientRect();
        const xy = isHorizontal.value ? "x" : "y";
        const XY = isHorizontal.value ? "X" : "Y";
        const rightBottom = isHorizontal.value ? "right" : "bottom";
        const widthHeight = isHorizontal.value ? "width" : "height";
        const prevPos = prevBox[xy];
        const nextPos = nextBox[xy];
        const delta = prevPos > nextPos ? prevBox[rightBottom] - nextBox[rightBottom] : prevBox[xy] - nextBox[xy];
        const origin = Math.sign(delta) > 0 ? isHorizontal.value ? "right" : "bottom" : Math.sign(delta) < 0 ? isHorizontal.value ? "left" : "top" : "center";
        const size = Math.abs(delta) + (Math.sign(delta) < 0 ? prevBox[widthHeight] : nextBox[widthHeight]);
        const scale = size / Math.max(prevBox[widthHeight], nextBox[widthHeight]);
        const initialScale = prevBox[widthHeight] / nextBox[widthHeight];
        const sigma = 1.5;
        nextEl.animate({
          backgroundColor: [color, ""],
          transform: [`translate${XY}(${delta}px) scale${XY}(${initialScale})`, `translate${XY}(${delta / sigma}px) scale${XY}(${(scale - 1) / sigma + 1})`, ""],
          transformOrigin: Array(3).fill(origin)
        }, {
          duration: 225,
          easing: standardEasing
        });
      }
    });
    useRender(() => {
      const [btnProps] = pick(props, ["href", "to", "replace", "icon", "stacked", "prependIcon", "appendIcon", "ripple", "theme", "disabled"]);
      return createVNode(VBtn, mergeProps({
        "ref": rootEl,
        "class": ["v-tab", selectedClass.value],
        "tabindex": isSelected.value ? 0 : -1,
        "role": "tab",
        "aria-selected": String(isSelected.value),
        "onClick": () => !props.disabled && select(!isSelected.value)
      }, btnProps, attrs), {
        default: () => [slots.default ? slots.default() : props.title, !props.hideSlider && createVNode("div", {
          "ref": sliderEl,
          "class": ["v-tab__slider", sliderColorClasses.value],
          "style": sliderColorStyles.value
        }, null)]
      });
    });
    return {
      isSelected
    };
  }
});

// node_modules/vuetify/lib/components/VTabs/VTabs.mjs
function parseItems(items) {
  if (!items)
    return [];
  return items.map((item) => {
    if (typeof item === "string")
      return {
        title: item,
        value: item
      };
    return item;
  });
}
var VTabsSymbol = Symbol.for("vuetify:v-tabs");
var VTabs = defineComponent2({
  name: "VTabs",
  props: __spreadValues(__spreadValues({
    alignWithTitle: Boolean,
    color: String,
    direction: {
      type: String,
      default: "horizontal"
    },
    fixedTabs: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    stacked: Boolean,
    backgroundColor: String,
    centered: Boolean,
    grow: Boolean,
    height: {
      type: [Number, String],
      default: void 0
    },
    hideSlider: Boolean,
    optional: Boolean,
    right: Boolean,
    sliderColor: String,
    modelValue: null
  }, makeDensityProps()), makeTagProps()),
  emits: {
    "update:modelValue": (v) => true
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const parsedItems = computed(() => parseItems(props.items));
    const {
      densityClasses
    } = useDensity(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "backgroundColor"));
    provideDefaults({
      VTab: {
        color: toRef(props, "color"),
        direction: toRef(props, "direction"),
        stacked: toRef(props, "stacked"),
        fixed: toRef(props, "fixedTabs"),
        sliderColor: toRef(props, "sliderColor"),
        hideSlider: toRef(props, "hideSlider")
      }
    });
    return () => createVNode(VSlideGroup, {
      "class": ["v-tabs", `v-tabs--${props.direction}`, {
        "v-tabs--align-with-title": props.alignWithTitle,
        "v-tabs--centered": props.centered,
        "v-tabs--fixed-tabs": props.fixedTabs,
        "v-tabs--grow": props.grow,
        "v-tabs--right": props.right,
        "v-tabs--stacked": props.stacked
      }, densityClasses.value, backgroundColorClasses.value],
      "style": backgroundColorStyles.value,
      "role": "tablist",
      "symbol": VTabsSymbol,
      "mandatory": "force",
      "direction": props.direction,
      "modelValue": props.modelValue,
      "onUpdate:modelValue": (v) => emit("update:modelValue", v)
    }, {
      default: () => [slots.default ? slots.default() : parsedItems.value.map((item) => createVNode(VTab, mergeProps(item, {
        "key": item.title
      }), null))]
    });
  }
});

// node_modules/vuetify/lib/components/VTable/VTable.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VTable/VTable.css";
var VTable = defineComponent2({
  name: "VTable",
  props: __spreadValues(__spreadValues(__spreadValues({
    fixedHeader: Boolean,
    fixedFooter: Boolean,
    height: [Number, String]
  }, makeDensityProps()), makeThemeProps()), makeTagProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      densityClasses
    } = useDensity(props);
    return () => {
      var _slots$top, _slots$default, _slots$bottom;
      return createVNode(props.tag, {
        "class": ["v-table", {
          "v-table--fixed-height": !!props.height,
          "v-table--fixed-header": props.fixedHeader,
          "v-table--fixed-footer": props.fixedFooter,
          "v-table--has-top": !!slots.top,
          "v-table--has-bottom": !!slots.bottom
        }, themeClasses.value, densityClasses.value]
      }, {
        default: () => [(_slots$top = slots.top) == null ? void 0 : _slots$top.call(slots), slots.default && createVNode("div", {
          "class": "v-table__wrapper",
          "style": {
            height: convertToUnit(props.height)
          }
        }, [createVNode("table", null, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)])]), (_slots$bottom = slots.bottom) == null ? void 0 : _slots$bottom.call(slots)]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VThemeProvider/VThemeProvider.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VThemeProvider/VThemeProvider.css";
var VThemeProvider = defineComponent2({
  name: "VThemeProvider",
  props: __spreadValues(__spreadValues({
    withBackground: Boolean
  }, makeThemeProps()), makeTagProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    return () => {
      var _slots$default, _slots$default2;
      if (!props.withBackground)
        return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
      return createVNode(props.tag, {
        "class": ["v-theme-provider", themeClasses.value]
      }, {
        default: () => [(_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots)]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VTimeline/VTimeline.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VTimeline/VTimeline.css";

// node_modules/vuetify/lib/components/VTimeline/shared.mjs
var VTimelineSymbol = Symbol.for("vuetify:timeline");

// node_modules/vuetify/lib/components/VTimeline/VTimelineDivider.mjs
var VTimelineDivider = defineComponent({
  name: "VTimelineDivider",
  props: __spreadValues(__spreadValues(__spreadValues({
    hideDot: Boolean,
    lineColor: String,
    icon: String,
    iconColor: String,
    fillDot: Boolean,
    dotColor: String
  }, makeRoundedProps()), makeSizeProps()), makeElevationProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const timeline = inject(VTimelineSymbol);
    if (!timeline)
      throw new Error("[Vuetify] Could not find v-timeline provider");
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props, "v-timeline-divider__dot");
    const {
      backgroundColorStyles,
      backgroundColorClasses
    } = useBackgroundColor(toRef(props, "dotColor"));
    const {
      backgroundColorStyles: lineColorStyles,
      backgroundColorClasses: lineColorClasses
    } = useBackgroundColor(timeline.lineColor);
    const {
      roundedClasses
    } = useRounded(props, "v-timeline-divider__dot");
    const {
      elevationClasses
    } = useElevation(props);
    return () => createVNode("div", {
      "class": ["v-timeline-divider", {
        "v-timeline-divider--fill-dot": props.fillDot
      }]
    }, [!props.hideDot && createVNode("div", {
      "class": ["v-timeline-divider__dot", roundedClasses.value, sizeClasses.value, elevationClasses.value],
      "style": sizeStyles.value
    }, [createVNode("div", {
      "class": ["v-timeline-divider__inner-dot", roundedClasses.value, backgroundColorClasses.value],
      "style": backgroundColorStyles.value
    }, [slots.default ? slots.default({
      icon: props.icon,
      iconColor: props.iconColor,
      size: props.size
    }) : props.icon ? createVNode(VIcon, {
      "icon": props.icon,
      "color": props.iconColor,
      "size": props.size
    }, null) : void 0])]), createVNode("div", {
      "class": ["v-timeline-divider__line", lineColorClasses.value],
      "style": lineColorStyles.value
    }, null)]);
  }
});

// node_modules/vuetify/lib/components/VTimeline/VTimelineItem.mjs
var VTimelineItem = defineComponent2({
  name: "VTimelineItem",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    hideOpposite: {
      type: Boolean,
      default: void 0
    },
    icon: String,
    iconColor: String
  }, makeRoundedProps()), makeElevationProps()), makeSizeProps()), makeTagProps()), makeDimensionProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const timeline = inject(VTimelineSymbol);
    if (!timeline)
      throw new Error("[Vuetify] Could not find v-timeline provider");
    const {
      dimensionStyles
    } = useDimension(props);
    const dotSize = ref(0);
    const dotRef = ref();
    watch(dotRef, (newValue) => {
      var _newValue$$el$querySe, _newValue$$el$querySe2;
      if (!newValue)
        return;
      dotSize.value = (_newValue$$el$querySe = (_newValue$$el$querySe2 = newValue.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : _newValue$$el$querySe2.getBoundingClientRect().width) != null ? _newValue$$el$querySe : 0;
    }, {
      flush: "post"
    });
    return () => {
      var _slots$default, _slots$opposite;
      return createVNode("div", {
        "class": ["v-timeline-item", {
          "v-timeline-item--fill-dot": props.fillDot
        }],
        "style": {
          "--v-timeline-dot-size": convertToUnit(dotSize.value)
        }
      }, [createVNode("div", {
        "class": "v-timeline-item__body",
        "style": dimensionStyles.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]), createVNode(VTimelineDivider, {
        "ref": dotRef,
        "hideDot": props.hideDot,
        "icon": props.icon,
        "iconColor": props.iconColor,
        "size": props.size,
        "elevation": props.elevation,
        "dotColor": props.dotColor,
        "fillDot": props.fillDot,
        "rounded": props.rounded
      }, {
        default: slots.icon
      }), timeline.density.value !== "compact" && createVNode("div", {
        "class": "v-timeline-item__opposite"
      }, [!props.hideOpposite && ((_slots$opposite = slots.opposite) == null ? void 0 : _slots$opposite.call(slots))])]);
    };
  }
});

// node_modules/vuetify/lib/components/VTimeline/VTimeline.mjs
var VTimeline = defineComponent2({
  name: "VTimeline",
  props: __spreadValues(__spreadValues(__spreadValues({
    direction: {
      type: String,
      default: "vertical",
      validator: (v) => ["vertical", "horizontal"].includes(v)
    },
    side: {
      type: String,
      validator: (v) => v == null || ["start", "end"].includes(v)
    },
    lineInset: {
      type: [String, Number],
      default: 0
    },
    lineThickness: {
      type: [String, Number],
      default: 2
    },
    lineColor: String,
    truncateLine: {
      type: String,
      default: "start",
      validator: (v) => ["none", "start", "end", "both"].includes(v)
    }
  }, makeDensityProps()), makeTagProps()), makeThemeProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      densityClasses
    } = useDensity(props);
    provide(VTimelineSymbol, {
      density: toRef(props, "density"),
      lineColor: toRef(props, "lineColor")
    });
    const sideClass = computed(() => {
      const side = props.side ? props.side : props.density !== "default" ? "end" : null;
      return side && `v-timeline--side-${side}`;
    });
    return () => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-timeline", `v-timeline--${props.direction}`, {
          "v-timeline--inset-line": !!props.lineInset,
          "v-timeline--truncate-line-end": props.truncateLine === "end" || props.truncateLine === "both"
        }, themeClasses.value, densityClasses.value, sideClass.value],
        "style": {
          "--v-timeline-line-thickness": convertToUnit(props.lineThickness),
          "--v-timeline-line-inset": convertToUnit(props.lineInset)
        }
      }, {
        default: () => [(props.truncateLine === "none" || props.truncateLine === "end") && createVNode(VTimelineItem, {
          "hideDot": true
        }, null), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VTooltip/VTooltip.mjs
import "D:/Muhammad Aziz Taufiqurrahman/Data Aziz Taufiqurrahman/Kuliah Polban/Semester 5/Pengembangan Web/TugasBesar/GridJournal/GridJournal2/node_modules/vuetify/lib/components/VTooltip/VTooltip.css";
var VTooltip = genericComponent()({
  name: "VTooltip",
  inheritAttrs: false,
  props: __spreadValues({
    id: String,
    modelValue: Boolean,
    text: String,
    anchor: {
      type: String,
      default: "end"
    },
    origin: {
      type: String,
      default: "auto"
    }
  }, makeTransitionProps({
    transition: false
  })),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const uid = getUid();
    const id = computed(() => props.id || `v-tooltip-${uid}`);
    const anchor = computed(() => {
      return props.anchor.split(" ").length > 1 ? props.anchor : props.anchor + " center";
    });
    const origin = computed(() => {
      return props.origin === "auto" || props.origin === "overlap" || props.origin.split(" ").length > 1 || props.anchor.split(" ").length > 1 ? props.origin : props.origin + " center";
    });
    const transition = computed(() => {
      if (props.transition)
        return props.transition;
      return isActive.value ? "scale-transition" : "fade-transition";
    });
    return () => {
      return createVNode(VOverlay, mergeProps({
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "class": ["v-tooltip"],
        "id": id.value,
        "transition": transition.value,
        "absolute": true,
        "positionStrategy": "connected",
        "scrollStrategy": "reposition",
        "anchor": anchor.value,
        "origin": origin.value,
        "min-width": 0,
        "offset": 10,
        "scrim": false,
        "persistent": true,
        "open-on-click": false,
        "open-on-hover": true,
        "role": "tooltip",
        "eager": true,
        "activatorProps": {
          "aria-describedby": id.value
        }
      }, attrs), {
        activator: slots.activator,
        default: function() {
          var _slots$default, _slots$default2;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return (_slots$default = (_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots, ...args)) != null ? _slots$default : props.text;
        }
      });
    };
  }
});

// node_modules/vuetify/lib/components/VValidation/VValidation.mjs
var VValidation = defineComponent2({
  name: "VValidation",
  props: __spreadValues({}, makeValidationProps()),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const validation = useValidation(props, "validation");
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, validation);
    };
  }
});
export {
  VAlert,
  VAlertTitle,
  VApp,
  VAppBar,
  VAppBarNavIcon,
  VAppBarTitle,
  VAutocomplete,
  VAvatar,
  VBadge,
  VBanner,
  VBannerActions,
  VBannerText,
  VBottomNavigation,
  VBreadcrumbs,
  VBreadcrumbsDivider,
  VBreadcrumbsItem,
  VBtn,
  VBtnGroup,
  VBtnToggle,
  VCard,
  VCardActions,
  VCardAvatar,
  VCardHeader,
  VCardHeaderText,
  VCardImg,
  VCardSubtitle,
  VCardText,
  VCardTitle,
  VCarousel,
  VCarouselItem,
  VCarouselReverseTransition,
  VCarouselTransition,
  VCheckbox,
  VChip,
  VChipGroup,
  VClassIcon,
  VCode,
  VCol,
  VColorPicker,
  VCombobox,
  VComponentIcon,
  VContainer,
  VCounter,
  VDefaultsProvider,
  VDialog,
  VDialogBottomTransition,
  VDialogTopTransition,
  VDialogTransition,
  VDivider,
  VExpandTransition,
  VExpandXTransition,
  VExpansionPanel,
  VExpansionPanelText,
  VExpansionPanelTitle,
  VExpansionPanels,
  VFabTransition,
  VFadeTransition,
  VField,
  VFieldLabel,
  VFileInput,
  VFooter,
  VForm,
  VHover,
  VIcon,
  VImg,
  VInput,
  VItem,
  VItemGroup,
  VKbd,
  VLabel,
  VLayout,
  VLayoutItem,
  VLazy,
  VLigatureIcon,
  VList,
  VListGroup,
  VListImg,
  VListItem,
  VListItemAvatar,
  VListItemHeader,
  VListItemMedia,
  VListItemSubtitle,
  VListItemTitle,
  VListSubheader,
  VLocaleProvider,
  VMain,
  VMenu,
  VMenuTransition,
  VMessages,
  VNavigationDrawer,
  VNoSsr,
  VOverlay,
  VPagination,
  VParallax,
  VProgressCircular,
  VProgressLinear,
  VRadio,
  VRadioGroup,
  VRangeSlider,
  VRating,
  VResponsive,
  VRow,
  VScaleTransition,
  VScrollXReverseTransition,
  VScrollXTransition,
  VScrollYReverseTransition,
  VScrollYTransition,
  VSelect,
  VSelectionControl,
  VSelectionControlGroup,
  VSheet,
  VSlideGroup,
  VSlideGroupItem,
  VSlideGroupSymbol,
  VSlideXReverseTransition,
  VSlideXTransition,
  VSlideYReverseTransition,
  VSlideYTransition,
  VSlider,
  VSnackbar,
  VSpacer,
  VSvgIcon,
  VSwitch,
  VSystemBar,
  VTab,
  VTabReverseTransition,
  VTabTransition,
  VTable,
  VTabs,
  VTextField,
  VTextarea,
  VThemeProvider,
  VTimeline,
  VTimelineItem,
  VToolbar,
  VToolbarItems,
  VToolbarTitle,
  VTooltip,
  VValidation,
  VWindow,
  VWindowItem
};
//# sourceMappingURL=vuetify_components.js.map
